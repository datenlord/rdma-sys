/* automatically generated by rust-bindgen 0.57.0 */

pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type size_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct timespec {
    pub tv_sec: __time_t,
    pub tv_nsec: __syscall_slong_t,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
impl Default for __pthread_internal_list {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
impl Default for __pthread_mutex_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: ::std::os::raw::c_ulonglong,
    pub __wseq32: __pthread_cond_s__bindgen_ty_1__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: ::std::os::raw::c_ulonglong,
    pub __g1_start32: __pthread_cond_s__bindgen_ty_2__bindgen_ty_1,
    _bindgen_union_align: u64,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
impl Default for __pthread_cond_s__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
impl Default for __pthread_cond_s {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_mutex_t {
    pub __data: __pthread_mutex_s,
    pub __size: [::std::os::raw::c_char; 40usize],
    pub __align: ::std::os::raw::c_long,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_pthread_mutex_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_mutex_t>(),
        40usize,
        concat!("Size of: ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_mutex_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_mutex_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_mutex_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_mutex_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union pthread_cond_t {
    pub __data: __pthread_cond_s,
    pub __size: [::std::os::raw::c_char; 48usize],
    pub __align: ::std::os::raw::c_longlong,
    _bindgen_union_align: [u64; 6usize],
}
#[test]
fn bindgen_test_layout_pthread_cond_t() {
    assert_eq!(
        ::std::mem::size_of::<pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(pthread_cond_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<pthread_cond_t>())).__align as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(pthread_cond_t),
            "::",
            stringify!(__align)
        )
    );
}
impl Default for pthread_cond_t {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
pub const IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM: ib_uverbs_flow_action_esp_keymat = 0;
pub type ib_uverbs_flow_action_esp_keymat = ::std::os::raw::c_uint;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE: ib_uverbs_flow_action_esp_replay = 0;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP: ib_uverbs_flow_action_esp_replay = 1;
pub type ib_uverbs_flow_action_esp_replay = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap {
    pub __bindgen_anon_1: ib_uverbs_flow_action_esp_encap__bindgen_ty_1,
    pub __bindgen_anon_2: ib_uverbs_flow_action_esp_encap__bindgen_ty_2,
    pub len: __u16,
    pub type_: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    pub val_ptr: *mut ::std::os::raw::c_void,
    pub val_ptr_data_u64: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>())).val_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>()))
                .val_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr_data_u64)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    pub next_ptr: *mut ib_uverbs_flow_action_esp_encap,
    pub next_ptr_data_u64: __u64,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>())).next_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>()))
                .next_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr_data_u64)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).type_ as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for ib_uverbs_flow_action_esp_encap {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ib_uverbs_flow_action_esp {
    pub spi: __u32,
    pub seq: __u32,
    pub tfc_pad: __u32,
    pub flags: __u32,
    pub hard_limit_pkts: __u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).tfc_pad as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(tfc_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).hard_limit_pkts as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(hard_limit_pkts)
        )
    );
}
pub const RDMA_DRIVER_UNKNOWN: rdma_driver_id = 0;
pub const RDMA_DRIVER_MLX5: rdma_driver_id = 1;
pub const RDMA_DRIVER_MLX4: rdma_driver_id = 2;
pub const RDMA_DRIVER_CXGB3: rdma_driver_id = 3;
pub const RDMA_DRIVER_CXGB4: rdma_driver_id = 4;
pub const RDMA_DRIVER_MTHCA: rdma_driver_id = 5;
pub const RDMA_DRIVER_BNXT_RE: rdma_driver_id = 6;
pub const RDMA_DRIVER_OCRDMA: rdma_driver_id = 7;
pub const RDMA_DRIVER_NES: rdma_driver_id = 8;
pub const RDMA_DRIVER_I40IW: rdma_driver_id = 9;
pub const RDMA_DRIVER_VMW_PVRDMA: rdma_driver_id = 10;
pub const RDMA_DRIVER_QEDR: rdma_driver_id = 11;
pub const RDMA_DRIVER_HNS: rdma_driver_id = 12;
pub const RDMA_DRIVER_USNIC: rdma_driver_id = 13;
pub const RDMA_DRIVER_RXE: rdma_driver_id = 14;
pub const RDMA_DRIVER_HFI1: rdma_driver_id = 15;
pub const RDMA_DRIVER_QIB: rdma_driver_id = 16;
pub const RDMA_DRIVER_EFA: rdma_driver_id = 17;
pub const RDMA_DRIVER_SIW: rdma_driver_id = 18;
pub type rdma_driver_id = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_gid {
    pub raw: [u8; 16usize],
    pub global: ibv_gid__bindgen_ty_1,
    _bindgen_union_align: [u64; 2usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
#[test]
fn bindgen_test_layout_ibv_gid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_gid__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_gid__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).subnet_prefix as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(subnet_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).interface_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(interface_id)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_gid() {
    assert_eq!(
        ::std::mem::size_of::<ibv_gid>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_gid))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_gid>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_gid))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_gid>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_gid>())).global as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid),
            "::",
            stringify!(global)
        )
    );
}
impl Default for ibv_gid {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_node_type {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_NODE_UNKNOWN: Type = -1;
    pub const IBV_NODE_CA: Type = 1;
    pub const IBV_NODE_SWITCH: Type = 2;
    pub const IBV_NODE_ROUTER: Type = 3;
    pub const IBV_NODE_RNIC: Type = 4;
    pub const IBV_NODE_USNIC: Type = 5;
    pub const IBV_NODE_USNIC_UDP: Type = 6;
    pub const IBV_NODE_UNSPECIFIED: Type = 7;
}
pub mod ibv_transport_type {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_TRANSPORT_UNKNOWN: Type = -1;
    pub const IBV_TRANSPORT_IB: Type = 0;
    pub const IBV_TRANSPORT_IWARP: Type = 1;
    pub const IBV_TRANSPORT_USNIC: Type = 2;
    pub const IBV_TRANSPORT_USNIC_UDP: Type = 3;
    pub const IBV_TRANSPORT_UNSPECIFIED: Type = 4;
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RESIZE_MAX_WR: ibv_device_cap_flags = ibv_device_cap_flags(1);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_BAD_PKEY_CNTR: ibv_device_cap_flags = ibv_device_cap_flags(2);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_BAD_QKEY_CNTR: ibv_device_cap_flags = ibv_device_cap_flags(4);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RAW_MULTI: ibv_device_cap_flags = ibv_device_cap_flags(8);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_AUTO_PATH_MIG: ibv_device_cap_flags = ibv_device_cap_flags(16);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_CHANGE_PHY_PORT: ibv_device_cap_flags = ibv_device_cap_flags(32);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_UD_AV_PORT_ENFORCE: ibv_device_cap_flags = ibv_device_cap_flags(64);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_CURR_QP_STATE_MOD: ibv_device_cap_flags = ibv_device_cap_flags(128);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SHUTDOWN_PORT: ibv_device_cap_flags = ibv_device_cap_flags(256);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_INIT_TYPE: ibv_device_cap_flags = ibv_device_cap_flags(512);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_PORT_ACTIVE_EVENT: ibv_device_cap_flags = ibv_device_cap_flags(1024);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SYS_IMAGE_GUID: ibv_device_cap_flags = ibv_device_cap_flags(2048);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RC_RNR_NAK_GEN: ibv_device_cap_flags = ibv_device_cap_flags(4096);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SRQ_RESIZE: ibv_device_cap_flags = ibv_device_cap_flags(8192);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_N_NOTIFY_CQ: ibv_device_cap_flags = ibv_device_cap_flags(16384);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW: ibv_device_cap_flags = ibv_device_cap_flags(131072);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_UD_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(262144);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_XRC: ibv_device_cap_flags = ibv_device_cap_flags(1048576);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_MGT_EXTENSIONS: ibv_device_cap_flags = ibv_device_cap_flags(2097152);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW_TYPE_2A: ibv_device_cap_flags = ibv_device_cap_flags(8388608);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW_TYPE_2B: ibv_device_cap_flags = ibv_device_cap_flags(16777216);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RC_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(33554432);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RAW_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(67108864);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MANAGED_FLOW_STEERING: ibv_device_cap_flags =
        ibv_device_cap_flags(536870912);
}
impl ::std::ops::BitOr<ibv_device_cap_flags> for ibv_device_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_device_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_device_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_device_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_device_cap_flags> for ibv_device_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_device_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_device_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_device_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_device_cap_flags(pub ::std::os::raw::c_uint);
pub mod ibv_atomic_cap {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_ATOMIC_NONE: Type = 0;
    pub const IBV_ATOMIC_HCA: Type = 1;
    pub const IBV_ATOMIC_GLOB: Type = 2;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_alloc_dm_attr {
    pub length: size_t,
    pub log_align_req: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_alloc_dm_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_alloc_dm_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_alloc_dm_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).log_align_req as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(log_align_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).comp_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: ::std::option::Option<
        unsafe extern "C" fn(
            dm: *mut ibv_dm,
            dm_offset: u64,
            host_addr: *const ::std::os::raw::c_void,
            length: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub memcpy_from_dm: ::std::option::Option<
        unsafe extern "C" fn(
            host_addr: *mut ::std::os::raw::c_void,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: size_t,
        ) -> ::std::os::raw::c_int,
    >,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_dm() {
    assert_eq!(
        ::std::mem::size_of::<ibv_dm>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_dm))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_dm>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_dm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_to_dm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_to_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_from_dm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_from_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).comp_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_dm {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap::Type,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
#[test]
fn bindgen_test_layout_ibv_device_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr>(),
        232usize,
        concat!("Size of: ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).fw_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(fw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).node_guid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(node_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).sys_image_guid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(sys_image_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).page_size_cap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(page_size_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_part_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_part_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).hw_ver as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(hw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_wr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_wr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).device_cap_flags as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(device_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge_rd as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge_rd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cqe as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pd as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_rd_atom as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_rd_atom as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_res_rd_atom as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_res_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_init_rd_atom as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_init_rd_atom as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).atomic_cap as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(atomic_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_rdd as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_rdd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mw as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ipv6_qp as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ipv6_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ethy_qp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ethy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_grp as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_grp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_qp_attach as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_total_mcast_qp_attach as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_total_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ah as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ah)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_fmr as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_map_per_fmr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_map_per_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_wr as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_sge as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pkeys as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pkeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).local_ca_ack_delay as *const _ as usize
        },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(local_ca_ack_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).phys_port_cnt as *const _ as usize },
        227usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(phys_port_cnt)
        )
    );
}
impl Default for ibv_device_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_query_device_ex_input() {
    assert_eq!(
        ::std::mem::size_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_query_device_ex_input>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_query_device_ex_input),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_SEND: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(1);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_RECV: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(2);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_WRITE: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(4);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_READ: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(8);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_ATOMIC: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(16);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_SRQ_RECV: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(32);
}
impl ::std::ops::BitOr<ibv_odp_transport_cap_bits> for ibv_odp_transport_cap_bits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_odp_transport_cap_bits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_odp_transport_cap_bits {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_odp_transport_cap_bits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_odp_transport_cap_bits> for ibv_odp_transport_cap_bits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_odp_transport_cap_bits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_odp_transport_cap_bits {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_odp_transport_cap_bits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_odp_transport_cap_bits(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
#[test]
fn bindgen_test_layout_ibv_odp_caps__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).rc_odp_caps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(rc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).uc_odp_caps as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(uc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).ud_odp_caps as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(ud_odp_caps)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_odp_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).general_caps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(general_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).per_transport_caps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(per_transport_caps)
        )
    );
}
impl ibv_odp_general_caps {
    pub const IBV_ODP_SUPPORT: ibv_odp_general_caps = ibv_odp_general_caps(1);
}
impl ibv_odp_general_caps {
    pub const IBV_ODP_SUPPORT_IMPLICIT: ibv_odp_general_caps = ibv_odp_general_caps(2);
}
impl ::std::ops::BitOr<ibv_odp_general_caps> for ibv_odp_general_caps {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_odp_general_caps(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_odp_general_caps {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_odp_general_caps) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_odp_general_caps> for ibv_odp_general_caps {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_odp_general_caps(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_odp_general_caps {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_odp_general_caps) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_odp_general_caps(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_tso_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tso_caps>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tso_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).max_tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(max_tso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).supported_qpts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
impl ibv_rx_hash_function_flags {
    pub const IBV_RX_HASH_FUNC_TOEPLITZ: ibv_rx_hash_function_flags = ibv_rx_hash_function_flags(1);
}
impl ::std::ops::BitOr<ibv_rx_hash_function_flags> for ibv_rx_hash_function_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rx_hash_function_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rx_hash_function_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rx_hash_function_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rx_hash_function_flags> for ibv_rx_hash_function_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rx_hash_function_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rx_hash_function_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rx_hash_function_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rx_hash_function_flags(pub ::std::os::raw::c_uint);
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_IPV4: ibv_rx_hash_fields = ibv_rx_hash_fields(1);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_IPV4: ibv_rx_hash_fields = ibv_rx_hash_fields(2);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_IPV6: ibv_rx_hash_fields = ibv_rx_hash_fields(4);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_IPV6: ibv_rx_hash_fields = ibv_rx_hash_fields(8);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_PORT_TCP: ibv_rx_hash_fields = ibv_rx_hash_fields(16);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_PORT_TCP: ibv_rx_hash_fields = ibv_rx_hash_fields(32);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_PORT_UDP: ibv_rx_hash_fields = ibv_rx_hash_fields(64);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_PORT_UDP: ibv_rx_hash_fields = ibv_rx_hash_fields(128);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_IPSEC_SPI: ibv_rx_hash_fields = ibv_rx_hash_fields(256);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_INNER: ibv_rx_hash_fields = ibv_rx_hash_fields(2147483648);
}
impl ::std::ops::BitOr<ibv_rx_hash_fields> for ibv_rx_hash_fields {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rx_hash_fields(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rx_hash_fields {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rx_hash_fields) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rx_hash_fields> for ibv_rx_hash_fields {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rx_hash_fields(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rx_hash_fields {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rx_hash_fields) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rx_hash_fields(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[test]
fn bindgen_test_layout_ibv_rss_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rss_caps>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rss_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).supported_qpts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_tables as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_table_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_table_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_function)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_packet_pacing_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_packet_pacing_caps>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_packet_pacing_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_max as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).supported_qpts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_CVLAN_STRIPPING: ibv_raw_packet_caps = ibv_raw_packet_caps(1);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_SCATTER_FCS: ibv_raw_packet_caps = ibv_raw_packet_caps(2);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_IP_CSUM: ibv_raw_packet_caps = ibv_raw_packet_caps(4);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_DELAY_DROP: ibv_raw_packet_caps = ibv_raw_packet_caps(8);
}
impl ::std::ops::BitOr<ibv_raw_packet_caps> for ibv_raw_packet_caps {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_raw_packet_caps(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_raw_packet_caps {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_raw_packet_caps) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_raw_packet_caps> for ibv_raw_packet_caps {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_raw_packet_caps(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_raw_packet_caps {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_raw_packet_caps) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_raw_packet_caps(pub ::std::os::raw::c_uint);
impl ibv_tm_cap_flags {
    pub const IBV_TM_CAP_RC: ibv_tm_cap_flags = ibv_tm_cap_flags(1);
}
impl ::std::ops::BitOr<ibv_tm_cap_flags> for ibv_tm_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_tm_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_tm_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_tm_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_tm_cap_flags> for ibv_tm_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_tm_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_tm_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_tm_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_tm_cap_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_caps>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_rndv_hdr_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_rndv_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_num_tags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_ops as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_sge)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_cq_moderation_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_moderation_caps>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_moderation_caps>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_period as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_period)
        )
    );
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(1);
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(2);
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(4);
}
impl ::std::ops::BitOr<ibv_pci_atomic_op_size> for ibv_pci_atomic_op_size {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_pci_atomic_op_size(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_pci_atomic_op_size {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_pci_atomic_op_size) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_pci_atomic_op_size> for ibv_pci_atomic_op_size {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_pci_atomic_op_size(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_pci_atomic_op_size {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_pci_atomic_op_size) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_pci_atomic_op_size(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_pci_atomic_caps {
    pub fetch_add: u16,
    pub swap: u16,
    pub compare_swap: u16,
}
#[test]
fn bindgen_test_layout_ibv_pci_atomic_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_pci_atomic_caps>(),
        6usize,
        concat!("Size of: ", stringify!(ibv_pci_atomic_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_pci_atomic_caps>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_pci_atomic_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).fetch_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(fetch_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).swap as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).compare_swap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(compare_swap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
    pub pci_atomic_caps: ibv_pci_atomic_caps,
    pub xrc_odp_caps: u32,
}
#[test]
fn bindgen_test_layout_ibv_device_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr_ex>(),
        400usize,
        concat!("Size of: ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).orig_attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(orig_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).comp_mask as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).odp_caps as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).completion_timestamp_mask as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(completion_timestamp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).hca_core_clock as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(hca_core_clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).device_cap_flags_ex as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(device_cap_flags_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tso_caps as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tso_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).rss_caps as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(rss_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_wq_type_rq as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_wq_type_rq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).packet_pacing_caps as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(packet_pacing_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).raw_packet_caps as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(raw_packet_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tm_caps as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tm_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).cq_mod_caps as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(cq_mod_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_dm_size as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_dm_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).pci_atomic_caps as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(pci_atomic_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).xrc_odp_caps as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(xrc_odp_caps)
        )
    );
}
impl Default for ibv_device_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_mtu {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MTU_256: Type = 1;
    pub const IBV_MTU_512: Type = 2;
    pub const IBV_MTU_1024: Type = 3;
    pub const IBV_MTU_2048: Type = 4;
    pub const IBV_MTU_4096: Type = 5;
}
pub mod ibv_port_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_PORT_NOP: Type = 0;
    pub const IBV_PORT_DOWN: Type = 1;
    pub const IBV_PORT_INIT: Type = 2;
    pub const IBV_PORT_ARMED: Type = 3;
    pub const IBV_PORT_ACTIVE: Type = 4;
    pub const IBV_PORT_ACTIVE_DEFER: Type = 5;
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SM: ibv_port_cap_flags = ibv_port_cap_flags(2);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_OPT_IPD_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_AUTO_MIGR_SUP: ibv_port_cap_flags = ibv_port_cap_flags(32);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SL_MAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(64);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_MKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(128);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(256);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LED_INFO_SUP: ibv_port_cap_flags = ibv_port_cap_flags(512);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SYS_IMAGE_GUID_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2048);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4096);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_EXTENDED_SPEEDS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16384);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CAP_MASK2_SUP: ibv_port_cap_flags = ibv_port_cap_flags(32768);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CM_SUP: ibv_port_cap_flags = ibv_port_cap_flags(65536);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SNMP_TUNNEL_SUP: ibv_port_cap_flags = ibv_port_cap_flags(131072);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_REINIT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(262144);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DEVICE_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(524288);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_VENDOR_CLASS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(1048576);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DR_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2097152);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CAP_MASK_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4194304);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_BOOT_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8388608);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LINK_LATENCY_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16777216);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CLIENT_REG_SUP: ibv_port_cap_flags = ibv_port_cap_flags(33554432);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_IP_BASED_GIDS: ibv_port_cap_flags = ibv_port_cap_flags(67108864);
}
impl ::std::ops::BitOr<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_port_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_port_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_port_cap_flags(pub ::std::os::raw::c_uint);
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_SET_NODE_DESC_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(1);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_INFO_EXT_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(2);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_VIRT_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(4);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(8);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_LINK_WIDTH_2X_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(16);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_LINK_SPEED_HDR_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(32);
}
impl ::std::ops::BitOr<ibv_port_cap_flags2> for ibv_port_cap_flags2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_port_cap_flags2(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_port_cap_flags2 {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_port_cap_flags2) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_port_cap_flags2> for ibv_port_cap_flags2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_port_cap_flags2(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_port_cap_flags2 {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_port_cap_flags2) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_port_cap_flags2(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_port_attr {
    pub state: ibv_port_state::Type,
    pub max_mtu: ibv_mtu::Type,
    pub active_mtu: ibv_mtu::Type,
    pub gid_tbl_len: ::std::os::raw::c_int,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub port_cap_flags2: u16,
}
#[test]
fn bindgen_test_layout_ibv_port_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_port_attr>(),
        52usize,
        concat!("Size of: ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_port_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_mtu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).gid_tbl_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(gid_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).port_cap_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(port_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_msg_sz as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_msg_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).bad_pkey_cntr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(bad_pkey_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).qkey_viol_cntr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(qkey_viol_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).pkey_tbl_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(pkey_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_lid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lmc as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lmc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_vl_num as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_vl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_sl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).subnet_timeout as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(subnet_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).init_type_reply as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(init_type_reply)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_width as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_speed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).phys_state as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(phys_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).link_layer as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(link_layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).flags as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).port_cap_flags2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(port_cap_flags2)
        )
    );
}
impl Default for ibv_port_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_event_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_EVENT_CQ_ERR: Type = 0;
    pub const IBV_EVENT_QP_FATAL: Type = 1;
    pub const IBV_EVENT_QP_REQ_ERR: Type = 2;
    pub const IBV_EVENT_QP_ACCESS_ERR: Type = 3;
    pub const IBV_EVENT_COMM_EST: Type = 4;
    pub const IBV_EVENT_SQ_DRAINED: Type = 5;
    pub const IBV_EVENT_PATH_MIG: Type = 6;
    pub const IBV_EVENT_PATH_MIG_ERR: Type = 7;
    pub const IBV_EVENT_DEVICE_FATAL: Type = 8;
    pub const IBV_EVENT_PORT_ACTIVE: Type = 9;
    pub const IBV_EVENT_PORT_ERR: Type = 10;
    pub const IBV_EVENT_LID_CHANGE: Type = 11;
    pub const IBV_EVENT_PKEY_CHANGE: Type = 12;
    pub const IBV_EVENT_SM_CHANGE: Type = 13;
    pub const IBV_EVENT_SRQ_ERR: Type = 14;
    pub const IBV_EVENT_SRQ_LIMIT_REACHED: Type = 15;
    pub const IBV_EVENT_QP_LAST_WQE_REACHED: Type = 16;
    pub const IBV_EVENT_CLIENT_REREGISTER: Type = 17;
    pub const IBV_EVENT_GID_CHANGE: Type = 18;
    pub const IBV_EVENT_WQ_FATAL: Type = 19;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_async_event {
    pub element: ibv_async_event__bindgen_ty_1,
    pub event_type: ibv_event_type::Type,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_async_event__bindgen_ty_1 {
    pub cq: *mut ibv_cq,
    pub qp: *mut ibv_qp,
    pub srq: *mut ibv_srq,
    pub wq: *mut ibv_wq,
    pub port_num: ::std::os::raw::c_int,
    _bindgen_union_align: u64,
}
#[test]
fn bindgen_test_layout_ibv_async_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).cq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).qp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).srq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).wq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).port_num as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(port_num)
        )
    );
}
impl Default for ibv_async_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_async_event() {
    assert_eq!(
        ::std::mem::size_of::<ibv_async_event>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_async_event))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_async_event>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_async_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_async_event>())).element as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event),
            "::",
            stringify!(element)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_async_event>())).event_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event),
            "::",
            stringify!(event_type)
        )
    );
}
impl Default for ibv_async_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_wc_status {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WC_SUCCESS: Type = 0;
    pub const IBV_WC_LOC_LEN_ERR: Type = 1;
    pub const IBV_WC_LOC_QP_OP_ERR: Type = 2;
    pub const IBV_WC_LOC_EEC_OP_ERR: Type = 3;
    pub const IBV_WC_LOC_PROT_ERR: Type = 4;
    pub const IBV_WC_WR_FLUSH_ERR: Type = 5;
    pub const IBV_WC_MW_BIND_ERR: Type = 6;
    pub const IBV_WC_BAD_RESP_ERR: Type = 7;
    pub const IBV_WC_LOC_ACCESS_ERR: Type = 8;
    pub const IBV_WC_REM_INV_REQ_ERR: Type = 9;
    pub const IBV_WC_REM_ACCESS_ERR: Type = 10;
    pub const IBV_WC_REM_OP_ERR: Type = 11;
    pub const IBV_WC_RETRY_EXC_ERR: Type = 12;
    pub const IBV_WC_RNR_RETRY_EXC_ERR: Type = 13;
    pub const IBV_WC_LOC_RDD_VIOL_ERR: Type = 14;
    pub const IBV_WC_REM_INV_RD_REQ_ERR: Type = 15;
    pub const IBV_WC_REM_ABORT_ERR: Type = 16;
    pub const IBV_WC_INV_EECN_ERR: Type = 17;
    pub const IBV_WC_INV_EEC_STATE_ERR: Type = 18;
    pub const IBV_WC_FATAL_ERR: Type = 19;
    pub const IBV_WC_RESP_TIMEOUT_ERR: Type = 20;
    pub const IBV_WC_GENERAL_ERR: Type = 21;
    pub const IBV_WC_TM_ERR: Type = 22;
    pub const IBV_WC_TM_RNDV_INCOMPLETE: Type = 23;
}
extern "C" {
    pub fn ibv_wc_status_str(status: ibv_wc_status::Type) -> *const ::std::os::raw::c_char;
}
pub mod ibv_wc_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WC_SEND: Type = 0;
    pub const IBV_WC_RDMA_WRITE: Type = 1;
    pub const IBV_WC_RDMA_READ: Type = 2;
    pub const IBV_WC_COMP_SWAP: Type = 3;
    pub const IBV_WC_FETCH_ADD: Type = 4;
    pub const IBV_WC_BIND_MW: Type = 5;
    pub const IBV_WC_LOCAL_INV: Type = 6;
    pub const IBV_WC_TSO: Type = 7;
    pub const IBV_WC_RECV: Type = 128;
    pub const IBV_WC_RECV_RDMA_WITH_IMM: Type = 129;
    pub const IBV_WC_TM_ADD: Type = 130;
    pub const IBV_WC_TM_DEL: Type = 131;
    pub const IBV_WC_TM_SYNC: Type = 132;
    pub const IBV_WC_TM_RECV: Type = 133;
    pub const IBV_WC_TM_NO_TAG: Type = 134;
    pub const IBV_WC_DRIVER1: Type = 135;
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_BYTE_LEN: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(1);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_IMM: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(2);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_QP_NUM: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(4);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SRC_QP: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(8);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SLID: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(16);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SL: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(32);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_DLID_PATH_BITS: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(64);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP: ibv_create_cq_wc_flags =
        ibv_create_cq_wc_flags(128);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_CVLAN: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(256);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_FLOW_TAG: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(512);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_TM_INFO: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(1024);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP_WALLCLOCK: ibv_create_cq_wc_flags =
        ibv_create_cq_wc_flags(2048);
}
impl ::std::ops::BitOr<ibv_create_cq_wc_flags> for ibv_create_cq_wc_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_create_cq_wc_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_create_cq_wc_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_create_cq_wc_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_create_cq_wc_flags> for ibv_create_cq_wc_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_create_cq_wc_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_create_cq_wc_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_create_cq_wc_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_create_cq_wc_flags(pub ::std::os::raw::c_uint);
impl ibv_wc_flags {
    pub const IBV_WC_GRH: ibv_wc_flags = ibv_wc_flags(1);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_IMM: ibv_wc_flags = ibv_wc_flags(2);
}
impl ibv_wc_flags {
    pub const IBV_WC_IP_CSUM_OK: ibv_wc_flags = ibv_wc_flags(4);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_INV: ibv_wc_flags = ibv_wc_flags(8);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_SYNC_REQ: ibv_wc_flags = ibv_wc_flags(16);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_MATCH: ibv_wc_flags = ibv_wc_flags(32);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_DATA_VALID: ibv_wc_flags = ibv_wc_flags(64);
}
impl ::std::ops::BitOr<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wc_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wc_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wc_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wc_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wc_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc {
    pub wr_id: u64,
    pub status: ibv_wc_status::Type,
    pub opcode: ibv_wc_opcode::Type,
    pub vendor_err: u32,
    pub byte_len: u32,
    pub __bindgen_anon_1: ibv_wc__bindgen_ty_1,
    pub qp_num: u32,
    pub src_qp: u32,
    pub wc_flags: ::std::os::raw::c_uint,
    pub pkey_index: u16,
    pub slid: u16,
    pub sl: u8,
    pub dlid_path_bits: u8,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_wc__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidated_rkey: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).imm_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).invalidated_rkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(invalidated_rkey)
        )
    );
}
impl Default for ibv_wc__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_wc() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_wc))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wc))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).status as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).opcode as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).vendor_err as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(vendor_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).byte_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).qp_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).src_qp as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(src_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).wc_flags as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).pkey_index as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).slid as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).sl as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc>())).dlid_path_bits as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc),
            "::",
            stringify!(dlid_path_bits)
        )
    );
}
impl Default for ibv_wc {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_access_flags {
    pub const IBV_ACCESS_LOCAL_WRITE: ibv_access_flags = ibv_access_flags(1);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_WRITE: ibv_access_flags = ibv_access_flags(2);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_READ: ibv_access_flags = ibv_access_flags(4);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_ATOMIC: ibv_access_flags = ibv_access_flags(8);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_MW_BIND: ibv_access_flags = ibv_access_flags(16);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ZERO_BASED: ibv_access_flags = ibv_access_flags(32);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ON_DEMAND: ibv_access_flags = ibv_access_flags(64);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_HUGETLB: ibv_access_flags = ibv_access_flags(128);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_RELAXED_ORDERING: ibv_access_flags = ibv_access_flags(1048576);
}
impl ::std::ops::BitOr<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_access_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_access_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_access_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_access_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_access_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_access_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_access_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind_info {
    pub mr: *mut ibv_mr,
    pub addr: u64,
    pub length: u64,
    pub mw_access_flags: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout_ibv_mw_bind_info() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw_bind_info>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_mw_bind_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw_bind_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw_bind_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).mr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind_info>())).length as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_mw_bind_info>())).mw_access_flags as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind_info),
            "::",
            stringify!(mw_access_flags)
        )
    );
}
impl Default for ibv_mw_bind_info {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_pd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_pd>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_pd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_pd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_pd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_pd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_td_init_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_td_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_td {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_td() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_td))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_td))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_td {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_FD: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(1);
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_OFLAGS: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(2);
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_RESERVED: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(4);
}
impl ::std::ops::BitOr<ibv_xrcd_init_attr_mask> for ibv_xrcd_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_xrcd_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_xrcd_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_xrcd_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_xrcd_init_attr_mask> for ibv_xrcd_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_xrcd_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_xrcd_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_xrcd_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_xrcd_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_xrcd_init_attr {
    pub comp_mask: u32,
    pub fd: ::std::os::raw::c_int,
    pub oflags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_xrcd_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd_init_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).oflags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(oflags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_xrcd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_xrcd {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_TRANSLATION: ibv_rereg_mr_flags = ibv_rereg_mr_flags(1);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_PD: ibv_rereg_mr_flags = ibv_rereg_mr_flags(2);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_ACCESS: ibv_rereg_mr_flags = ibv_rereg_mr_flags(4);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_KEEP_VALID: ibv_rereg_mr_flags = ibv_rereg_mr_flags(8);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_FLAGS_SUPPORTED: ibv_rereg_mr_flags = ibv_rereg_mr_flags(15);
}
impl ::std::ops::BitOr<ibv_rereg_mr_flags> for ibv_rereg_mr_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rereg_mr_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rereg_mr_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rereg_mr_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rereg_mr_flags> for ibv_rereg_mr_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rereg_mr_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rereg_mr_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rereg_mr_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rereg_mr_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: size_t,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_mr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).handle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).lkey as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(lkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).rkey as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(rkey)
        )
    );
}
impl Default for ibv_mr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_mw_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MW_TYPE_1: Type = 1;
    pub const IBV_MW_TYPE_2: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type::Type,
}
#[test]
fn bindgen_test_layout_ibv_mw() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_mw))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).rkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).handle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(type_)
        )
    );
}
impl Default for ibv_mw {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_global_route {
    pub dgid: ibv_gid,
    pub flow_label: u32,
    pub sgid_index: u8,
    pub hop_limit: u8,
    pub traffic_class: u8,
}
#[test]
fn bindgen_test_layout_ibv_global_route() {
    assert_eq!(
        ::std::mem::size_of::<ibv_global_route>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_global_route))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_global_route>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_global_route))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).dgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).flow_label as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).sgid_index as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(sgid_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).hop_limit as *const _ as usize },
        21usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_global_route>())).traffic_class as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_global_route),
            "::",
            stringify!(traffic_class)
        )
    );
}
impl Default for ibv_global_route {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_grh {
    pub version_tclass_flow: __be32,
    pub paylen: __be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
}
#[test]
fn bindgen_test_layout_ibv_grh() {
    assert_eq!(
        ::std::mem::size_of::<ibv_grh>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_grh))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_grh>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_grh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).version_tclass_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(version_tclass_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).paylen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(paylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).next_hdr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).hop_limit as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).sgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).dgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(dgid)
        )
    );
}
impl Default for ibv_grh {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_rate {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_RATE_MAX: Type = 0;
    pub const IBV_RATE_2_5_GBPS: Type = 2;
    pub const IBV_RATE_5_GBPS: Type = 5;
    pub const IBV_RATE_10_GBPS: Type = 3;
    pub const IBV_RATE_20_GBPS: Type = 6;
    pub const IBV_RATE_30_GBPS: Type = 4;
    pub const IBV_RATE_40_GBPS: Type = 7;
    pub const IBV_RATE_60_GBPS: Type = 8;
    pub const IBV_RATE_80_GBPS: Type = 9;
    pub const IBV_RATE_120_GBPS: Type = 10;
    pub const IBV_RATE_14_GBPS: Type = 11;
    pub const IBV_RATE_56_GBPS: Type = 12;
    pub const IBV_RATE_112_GBPS: Type = 13;
    pub const IBV_RATE_168_GBPS: Type = 14;
    pub const IBV_RATE_25_GBPS: Type = 15;
    pub const IBV_RATE_100_GBPS: Type = 16;
    pub const IBV_RATE_200_GBPS: Type = 17;
    pub const IBV_RATE_300_GBPS: Type = 18;
    pub const IBV_RATE_28_GBPS: Type = 19;
    pub const IBV_RATE_50_GBPS: Type = 20;
    pub const IBV_RATE_400_GBPS: Type = 21;
    pub const IBV_RATE_600_GBPS: Type = 22;
}
extern "C" {
    #[doc = " ibv_rate_to_mult - Convert the IB rate enum to a multiple of the"]
    #[doc = " base rate of 2.5 Gbit/sec.  For example, IBV_RATE_5_GBPS will be"]
    #[doc = " converted to 2, since 5 Gbit/sec is 2 * 2.5 Gbit/sec."]
    #[doc = " @rate: rate to convert."]
    pub fn ibv_rate_to_mult(rate: ibv_rate::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_rate_to_mbps - Convert the IB rate enum to Mbit/sec."]
    #[doc = " For example, IBV_RATE_5_GBPS will return the value 5000."]
    #[doc = " @rate: rate to convert."]
    pub fn ibv_rate_to_mbps(rate: ibv_rate::Type) -> ::std::os::raw::c_int;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah_attr {
    pub grh: ibv_global_route,
    pub dlid: u16,
    pub sl: u8,
    pub src_path_bits: u8,
    pub static_rate: u8,
    pub is_global: u8,
    pub port_num: u8,
}
#[test]
fn bindgen_test_layout_ibv_ah_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ah_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_ah_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ah_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ah_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).grh as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(grh)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).dlid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).sl as *const _ as usize },
        26usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).src_path_bits as *const _ as usize },
        27usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(src_path_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).static_rate as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(static_rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).is_global as *const _ as usize },
        29usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(is_global)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah_attr>())).port_num as *const _ as usize },
        30usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah_attr),
            "::",
            stringify!(port_num)
        )
    );
}
impl Default for ibv_ah_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_srq_attr_mask {
    pub const IBV_SRQ_MAX_WR: ibv_srq_attr_mask = ibv_srq_attr_mask(1);
}
impl ibv_srq_attr_mask {
    pub const IBV_SRQ_LIMIT: ibv_srq_attr_mask = ibv_srq_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_srq_attr_mask> for ibv_srq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_srq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_srq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_srq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_srq_attr_mask> for ibv_srq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_srq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_srq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_srq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_srq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_sge as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).srq_limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(srq_limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).srq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(attr)
        )
    );
}
impl Default for ibv_srq_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_srq_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_SRQT_BASIC: Type = 0;
    pub const IBV_SRQT_XRC: Type = 1;
    pub const IBV_SRQT_TM: Type = 2;
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_TYPE: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(1);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_PD: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(2);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_XRCD: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(4);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_CQ: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(8);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_TM: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(16);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_RESERVED: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(32);
}
impl ::std::ops::BitOr<ibv_srq_init_attr_mask> for ibv_srq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_srq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_srq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_srq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_srq_init_attr_mask> for ibv_srq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_srq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_srq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_srq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_srq_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_tm_cap {
    pub max_num_tags: u32,
    pub max_ops: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_cap>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_num_tags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_ops)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_srq_init_attr_ex {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
    pub comp_mask: u32,
    pub srq_type: ibv_srq_type::Type,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub cq: *mut ibv_cq,
    pub tm_cap: ibv_tm_cap,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr_ex>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_context as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).comp_mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).pd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).xrcd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).cq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).tm_cap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(tm_cap)
        )
    );
}
impl Default for ibv_srq_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_wq_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WQT_RQ: Type = 0;
}
impl ibv_wq_init_attr_mask {
    pub const IBV_WQ_INIT_ATTR_FLAGS: ibv_wq_init_attr_mask = ibv_wq_init_attr_mask(1);
}
impl ibv_wq_init_attr_mask {
    pub const IBV_WQ_INIT_ATTR_RESERVED: ibv_wq_init_attr_mask = ibv_wq_init_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_wq_init_attr_mask> for ibv_wq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_init_attr_mask> for ibv_wq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_CVLAN_STRIPPING: ibv_wq_flags = ibv_wq_flags(1);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_SCATTER_FCS: ibv_wq_flags = ibv_wq_flags(2);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_DELAY_DROP: ibv_wq_flags = ibv_wq_flags(4);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_PCI_WRITE_END_PADDING: ibv_wq_flags = ibv_wq_flags(8);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_RESERVED: ibv_wq_flags = ibv_wq_flags(16);
}
impl ::std::ops::BitOr<ibv_wq_flags> for ibv_wq_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_flags> for ibv_wq_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut ::std::os::raw::c_void,
    pub wq_type: ibv_wq_type::Type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_init_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_wr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).pd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).create_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(create_flags)
        )
    );
}
impl Default for ibv_wq_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_wq_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WQS_RESET: Type = 0;
    pub const IBV_WQS_RDY: Type = 1;
    pub const IBV_WQS_ERR: Type = 2;
    pub const IBV_WQS_UNKNOWN: Type = 3;
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_STATE: ibv_wq_attr_mask = ibv_wq_attr_mask(1);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_CURR_STATE: ibv_wq_attr_mask = ibv_wq_attr_mask(2);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_FLAGS: ibv_wq_attr_mask = ibv_wq_attr_mask(4);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_RESERVED: ibv_wq_attr_mask = ibv_wq_attr_mask(8);
}
impl ::std::ops::BitOr<ibv_wq_attr_mask> for ibv_wq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_attr_mask> for ibv_wq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state::Type,
    pub curr_wq_state: ibv_wq_state::Type,
    pub flags: u32,
    pub flags_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).wq_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).curr_wq_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(curr_wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags_mask)
        )
    );
}
impl Default for ibv_wq_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: ::std::os::raw::c_int,
    pub ind_tbl_num: ::std::os::raw::c_int,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_num as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).comp_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_rwq_ind_table {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_ind_table_init_attr_mask {
    pub const IBV_CREATE_IND_TABLE_RESERVED: ibv_ind_table_init_attr_mask =
        ibv_ind_table_init_attr_mask(1);
}
impl ::std::ops::BitOr<ibv_ind_table_init_attr_mask> for ibv_ind_table_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_ind_table_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_ind_table_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_ind_table_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_ind_table_init_attr_mask> for ibv_ind_table_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_ind_table_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_ind_table_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_ind_table_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_ind_table_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).log_ind_tbl_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(log_ind_tbl_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).ind_tbl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_rwq_ind_table_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_qp_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_QPT_RC: Type = 2;
    pub const IBV_QPT_UC: Type = 3;
    pub const IBV_QPT_UD: Type = 4;
    pub const IBV_QPT_RAW_PACKET: Type = 8;
    pub const IBV_QPT_XRC_SEND: Type = 9;
    pub const IBV_QPT_XRC_RECV: Type = 10;
    pub const IBV_QPT_DRIVER: Type = 255;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_cap>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_wr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_sge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_sge as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_inline_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_inline_data)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(sq_sig_all)
        )
    );
}
impl Default for ibv_qp_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_PD: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(1);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_XRCD: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(2);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_CREATE_FLAGS: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(4);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_MAX_TSO_HEADER: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(8);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_IND_TABLE: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(16);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_RX_HASH: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(32);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_SEND_OPS_FLAGS: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(64);
}
impl ::std::ops::BitOr<ibv_qp_init_attr_mask> for ibv_qp_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_init_attr_mask> for ibv_qp_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_BLOCK_SELF_MCAST_LB: ibv_qp_create_flags = ibv_qp_create_flags(2);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_SCATTER_FCS: ibv_qp_create_flags = ibv_qp_create_flags(256);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_CVLAN_STRIPPING: ibv_qp_create_flags = ibv_qp_create_flags(512);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_SOURCE_QPN: ibv_qp_create_flags = ibv_qp_create_flags(1024);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_PCI_WRITE_END_PADDING: ibv_qp_create_flags = ibv_qp_create_flags(2048);
}
impl ::std::ops::BitOr<ibv_qp_create_flags> for ibv_qp_create_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_create_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_create_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_create_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_create_flags> for ibv_qp_create_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_create_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_create_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_create_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_create_flags(pub ::std::os::raw::c_uint);
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_WRITE: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(1);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_WRITE_WITH_IMM: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(2);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND: ibv_qp_create_send_ops_flags = ibv_qp_create_send_ops_flags(4);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND_WITH_IMM: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(8);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_READ: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(16);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_ATOMIC_CMP_AND_SWP: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(32);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_ATOMIC_FETCH_AND_ADD: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(64);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_LOCAL_INV: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(128);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_BIND_MW: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(256);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND_WITH_INV: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(512);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_TSO: ibv_qp_create_send_ops_flags = ibv_qp_create_send_ops_flags(1024);
}
impl ::std::ops::BitOr<ibv_qp_create_send_ops_flags> for ibv_qp_create_send_ops_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_create_send_ops_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_create_send_ops_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_create_send_ops_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_create_send_ops_flags> for ibv_qp_create_send_ops_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_create_send_ops_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_create_send_ops_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_create_send_ops_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_create_send_ops_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_rx_hash_conf() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rx_hash_conf>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rx_hash_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
}
impl Default for ibv_rx_hash_conf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
    pub send_ops_flags: u64,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr_ex>(),
        136usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(sq_sig_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).comp_mask as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).pd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).xrcd as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).create_flags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(create_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).max_tso_header as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(max_tso_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rwq_ind_tbl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rwq_ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rx_hash_conf as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rx_hash_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).source_qpn as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(source_qpn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).send_ops_flags as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(send_ops_flags)
        )
    );
}
impl Default for ibv_qp_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_NUM: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(1);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_XRCD: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(2);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_CONTEXT: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(4);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_TYPE: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(8);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_RESERVED: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(16);
}
impl ::std::ops::BitOr<ibv_qp_open_attr_mask> for ibv_qp_open_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_open_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_open_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_open_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_open_attr_mask> for ibv_qp_open_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_open_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_open_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_open_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_open_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_qp_open_attr {
    pub comp_mask: u32,
    pub qp_num: u32,
    pub xrcd: *mut ibv_xrcd,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_ibv_qp_open_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_open_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_open_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_num as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).xrcd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for ibv_qp_open_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(1);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CUR_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(2);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_EN_SQD_ASYNC_NOTIFY: ibv_qp_attr_mask = ibv_qp_attr_mask(4);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ACCESS_FLAGS: ibv_qp_attr_mask = ibv_qp_attr_mask(8);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PKEY_INDEX: ibv_qp_attr_mask = ibv_qp_attr_mask(16);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PORT: ibv_qp_attr_mask = ibv_qp_attr_mask(32);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_QKEY: ibv_qp_attr_mask = ibv_qp_attr_mask(64);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_AV: ibv_qp_attr_mask = ibv_qp_attr_mask(128);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MTU: ibv_qp_attr_mask = ibv_qp_attr_mask(256);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_TIMEOUT: ibv_qp_attr_mask = ibv_qp_attr_mask(512);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RETRY_CNT: ibv_qp_attr_mask = ibv_qp_attr_mask(1024);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RNR_RETRY: ibv_qp_attr_mask = ibv_qp_attr_mask(2048);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(4096);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_QP_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(8192);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ALT_PATH: ibv_qp_attr_mask = ibv_qp_attr_mask(16384);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MIN_RNR_TIMER: ibv_qp_attr_mask = ibv_qp_attr_mask(32768);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_SQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(65536);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_DEST_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(131072);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MIG_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(262144);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CAP: ibv_qp_attr_mask = ibv_qp_attr_mask(524288);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_DEST_QPN: ibv_qp_attr_mask = ibv_qp_attr_mask(1048576);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RATE_LIMIT: ibv_qp_attr_mask = ibv_qp_attr_mask(33554432);
}
impl ::std::ops::BitOr<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_attr_mask(pub ::std::os::raw::c_uint);
pub mod ibv_qp_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_QPS_RESET: Type = 0;
    pub const IBV_QPS_INIT: Type = 1;
    pub const IBV_QPS_RTR: Type = 2;
    pub const IBV_QPS_RTS: Type = 3;
    pub const IBV_QPS_SQD: Type = 4;
    pub const IBV_QPS_SQE: Type = 5;
    pub const IBV_QPS_ERR: Type = 6;
    pub const IBV_QPS_UNKNOWN: Type = 7;
}
pub mod ibv_mig_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MIG_MIGRATED: Type = 0;
    pub const IBV_MIG_REARM: Type = 1;
    pub const IBV_MIG_ARMED: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state::Type,
    pub cur_qp_state: ibv_qp_state::Type,
    pub path_mtu: ibv_mtu::Type,
    pub path_mig_state: ibv_mig_state::Type,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: ::std::os::raw::c_uint,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_attr>(),
        144usize,
        concat!("Size of: ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cur_qp_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cur_qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mig_state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mig_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rq_psn as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_psn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).dest_qp_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(dest_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_access_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_access_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cap as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).ah_attr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_ah_attr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).pkey_index as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_pkey_index as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).en_sqd_async_notify as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(en_sqd_async_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_draining as *const _ as usize },
        125usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_draining)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_rd_atomic as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_dest_rd_atomic as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_dest_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).min_rnr_timer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(min_rnr_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).port_num as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).timeout as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).retry_cnt as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(retry_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rnr_retry as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rnr_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_port_num as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_timeout as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rate_limit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rate_limit)
        )
    );
}
impl Default for ibv_qp_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_qp_rate_limit_attr {
    pub rate_limit: u32,
    pub max_burst_sz: u32,
    pub typical_pkt_sz: u16,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_rate_limit_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_rate_limit_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_rate_limit_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).rate_limit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(rate_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).max_burst_sz as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(max_burst_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).typical_pkt_sz as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(typical_pkt_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).comp_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
pub mod ibv_wr_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WR_RDMA_WRITE: Type = 0;
    pub const IBV_WR_RDMA_WRITE_WITH_IMM: Type = 1;
    pub const IBV_WR_SEND: Type = 2;
    pub const IBV_WR_SEND_WITH_IMM: Type = 3;
    pub const IBV_WR_RDMA_READ: Type = 4;
    pub const IBV_WR_ATOMIC_CMP_AND_SWP: Type = 5;
    pub const IBV_WR_ATOMIC_FETCH_AND_ADD: Type = 6;
    pub const IBV_WR_LOCAL_INV: Type = 7;
    pub const IBV_WR_BIND_MW: Type = 8;
    pub const IBV_WR_SEND_WITH_INV: Type = 9;
    pub const IBV_WR_TSO: Type = 10;
    pub const IBV_WR_DRIVER1: Type = 11;
}
impl ibv_send_flags {
    pub const IBV_SEND_FENCE: ibv_send_flags = ibv_send_flags(1);
}
impl ibv_send_flags {
    pub const IBV_SEND_SIGNALED: ibv_send_flags = ibv_send_flags(2);
}
impl ibv_send_flags {
    pub const IBV_SEND_SOLICITED: ibv_send_flags = ibv_send_flags(4);
}
impl ibv_send_flags {
    pub const IBV_SEND_INLINE: ibv_send_flags = ibv_send_flags(8);
}
impl ibv_send_flags {
    pub const IBV_SEND_IP_CSUM: ibv_send_flags = ibv_send_flags(16);
}
impl ::std::ops::BitOr<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_send_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_send_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_send_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_send_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_send_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_send_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_send_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_data_buf {
    pub addr: *mut ::std::os::raw::c_void,
    pub length: size_t,
}
#[test]
fn bindgen_test_layout_ibv_data_buf() {
    assert_eq!(
        ::std::mem::size_of::<ibv_data_buf>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_data_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_data_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_data_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_data_buf>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_data_buf),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_data_buf>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_data_buf),
            "::",
            stringify!(length)
        )
    );
}
impl Default for ibv_data_buf {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_sge() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sge>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_sge))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sge>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).lkey as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(lkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr {
    pub wr_id: u64,
    pub next: *mut ibv_send_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub opcode: ibv_wr_opcode::Type,
    pub send_flags: ::std::os::raw::c_uint,
    pub __bindgen_anon_1: ibv_send_wr__bindgen_ty_1,
    pub wr: ibv_send_wr__bindgen_ty_2,
    pub qp_type: ibv_send_wr__bindgen_ty_3,
    pub __bindgen_anon_2: ibv_send_wr__bindgen_ty_4,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __be32,
    pub invalidate_rkey: u32,
    _bindgen_union_align: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).imm_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).invalidate_rkey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(invalidate_rkey)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_2 {
    pub rdma: ibv_send_wr__bindgen_ty_2__bindgen_ty_1,
    pub atomic: ibv_send_wr__bindgen_ty_2__bindgen_ty_2,
    pub ud: ibv_send_wr__bindgen_ty_2__bindgen_ty_3,
    _bindgen_union_align: [u64; 4usize],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).compare_add
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(compare_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).swap as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).rkey as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).ah as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qpn
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qpn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qkey
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qkey)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).rdma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(rdma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(ud)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_3 {
    pub xrc: ibv_send_wr__bindgen_ty_3__bindgen_ty_1,
    _bindgen_union_align: u32,
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>())).remote_srqn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(remote_srqn)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3>())).xrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3),
            "::",
            stringify!(xrc)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: ibv_send_wr__bindgen_ty_4__bindgen_ty_1,
    pub tso: ibv_send_wr__bindgen_ty_4__bindgen_ty_2,
    _bindgen_union_align: [u64; 6usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).mw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(mw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).bind_info
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(bind_info)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).mss as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(mss)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).bind_mw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(tso)
        )
    );
}
impl Default for ibv_send_wr__bindgen_ty_4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_send_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_send_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).sg_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).num_sge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(num_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).opcode as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).send_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(send_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).wr as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr>())).qp_type as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for ibv_send_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_recv_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_recv_wr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_recv_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).sg_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).num_sge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(num_sge)
        )
    );
}
impl Default for ibv_recv_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_ops_wr_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WR_TAG_ADD: Type = 0;
    pub const IBV_WR_TAG_DEL: Type = 1;
    pub const IBV_WR_TAG_SYNC: Type = 2;
}
impl ibv_ops_flags {
    pub const IBV_OPS_SIGNALED: ibv_ops_flags = ibv_ops_flags(1);
}
impl ibv_ops_flags {
    pub const IBV_OPS_TM_SYNC: ibv_ops_flags = ibv_ops_flags(2);
}
impl ::std::ops::BitOr<ibv_ops_flags> for ibv_ops_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_ops_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_ops_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_ops_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_ops_flags> for ibv_ops_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_ops_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_ops_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_ops_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_ops_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr {
    pub wr_id: u64,
    pub next: *mut ibv_ops_wr,
    pub opcode: ibv_ops_wr_opcode::Type,
    pub flags: ::std::os::raw::c_int,
    pub tm: ibv_ops_wr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1 {
    pub unexpected_cnt: u32,
    pub handle: u32,
    pub add: ibv_ops_wr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    pub recv_wr_id: u64,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub tag: u64,
    pub mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).recv_wr_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(recv_wr_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).sg_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).num_sge as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(num_sge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).tag as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).mask as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).unexpected_cnt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(unexpected_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(add)
        )
    );
}
impl Default for ibv_ops_wr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_ops_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).opcode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).tm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(tm)
        )
    );
}
impl Default for ibv_ops_wr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_mw_bind() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw_bind>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw_bind>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).send_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(send_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).bind_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(bind_info)
        )
    );
}
impl Default for ibv_mw_bind {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_srq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).srq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(events_completed)
        )
    );
}
impl Default for ibv_srq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state::Type,
    pub wq_type: ibv_wq_type::Type,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_wq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq>(),
        152usize,
        concat!("Size of: ", stringify!(ibv_wq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_num as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).handle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_type as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).post_recv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).mutex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cond as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).events_completed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).comp_mask as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_wq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state::Type,
    pub qp_type: ibv_qp_type::Type,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp>(),
        160usize,
        concat!("Size of: ", stringify!(ibv_qp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).send_cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).recv_cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).srq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).handle as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_num as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_type as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).mutex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).cond as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).events_completed as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(events_completed)
        )
    );
}
impl Default for ibv_qp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_ex {
    pub qp_base: ibv_qp,
    pub comp_mask: u64,
    pub wr_id: u64,
    pub wr_flags: ::std::os::raw::c_uint,
    pub wr_atomic_cmp_swp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            rkey: u32,
            remote_addr: u64,
            compare: u64,
            swap: u64,
        ),
    >,
    pub wr_atomic_fetch_add: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, add: u64),
    >,
    pub wr_bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            mw: *mut ibv_mw,
            rkey: u32,
            bind_info: *const ibv_mw_bind_info,
        ),
    >,
    pub wr_local_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_rdma_read: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write_imm: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, imm_data: __be32),
    >,
    pub wr_send: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_send_imm:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, imm_data: __be32)>,
    pub wr_send_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_send_tso: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            hdr: *mut ::std::os::raw::c_void,
            hdr_sz: u16,
            mss: u16,
        ),
    >,
    pub wr_set_ud_addr: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            ah: *mut ibv_ah,
            remote_qpn: u32,
            remote_qkey: u32,
        ),
    >,
    pub wr_set_xrc_srqn:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, remote_srqn: u32)>,
    pub wr_set_inline_data: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, addr: *mut ::std::os::raw::c_void, length: size_t),
    >,
    pub wr_set_inline_data_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_buf: size_t, buf_list: *const ibv_data_buf),
    >,
    pub wr_set_sge: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, lkey: u32, addr: u64, length: u32),
    >,
    pub wr_set_sge_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_sge: size_t, sg_list: *const ibv_sge),
    >,
    pub wr_start: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_complete:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex) -> ::std::os::raw::c_int>,
    pub wr_abort: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
}
#[test]
fn bindgen_test_layout_ibv_qp_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_ex>(),
        344usize,
        concat!("Size of: ", stringify!(ibv_qp_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).qp_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(qp_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).comp_mask as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_id as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_atomic_cmp_swp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_atomic_cmp_swp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_atomic_fetch_add as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_atomic_fetch_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_bind_mw as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_local_inv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_local_inv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_read as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_write as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_write_imm as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_write_imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_imm as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_inv as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_inv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_tso as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_tso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_ud_addr as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_ud_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_xrc_srqn as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_xrc_srqn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_inline_data as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_inline_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_inline_data_list as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_inline_data_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_sge as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_sge_list as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_sge_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_start as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_complete as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_abort as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_abort)
        )
    );
}
impl Default for ibv_qp_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    pub fn ibv_qp_to_qp_ex(qp: *mut ibv_qp) -> *mut ibv_qp_ex;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_comp_channel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_comp_channel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_comp_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).refcnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(refcnt)
        )
    );
}
impl Default for ibv_comp_channel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).async_events_completed as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(async_events_completed)
        )
    );
}
impl Default for ibv_cq {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_poll_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_poll_cq_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_poll_cq_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub priv_: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc_tm_info() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc_tm_info>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc_tm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub cond: pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status::Type,
    pub wr_id: u64,
    pub start_poll: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_cq_ex,
            attr: *mut ibv_poll_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_poll: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_int,
    >,
    pub end_poll: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex)>,
    pub read_opcode:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ibv_wc_opcode::Type>,
    pub read_vendor_err:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_byte_len: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_imm_data:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> __be32>,
    pub read_qp_num: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_src_qp: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_wc_flags: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_uint,
    >,
    pub read_slid: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_sl: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_dlid_path_bits:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_completion_ts:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
    pub read_cvlan: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u16>,
    pub read_flow_tag: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_tm_info: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex, tm_info: *mut ibv_wc_tm_info),
    >,
    pub read_completion_wallclock_ns:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
}
#[test]
fn bindgen_test_layout_ibv_cq_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_ex>(),
        288usize,
        concat!("Size of: ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).async_events_completed as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(async_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_mask as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).status as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).wr_id as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).start_poll as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(start_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).next_poll as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(next_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).end_poll as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(end_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_opcode as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_vendor_err as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_vendor_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_byte_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_imm_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_imm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_qp_num as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_src_qp as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_src_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_wc_flags as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_slid as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_sl as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_dlid_path_bits as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_dlid_path_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_ts as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_cvlan as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_cvlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_flow_tag as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_flow_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_tm_info as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_tm_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_wallclock_ns as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_wallclock_ns)
        )
    );
}
impl Default for ibv_cq_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_cq_attr_mask {
    pub const IBV_CQ_ATTR_MODERATE: ibv_cq_attr_mask = ibv_cq_attr_mask(1);
}
impl ibv_cq_attr_mask {
    pub const IBV_CQ_ATTR_RESERVED: ibv_cq_attr_mask = ibv_cq_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_cq_attr_mask> for ibv_cq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_cq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_cq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_cq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_cq_attr_mask> for ibv_cq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_cq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_cq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_cq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_cq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_moderate_cq {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_moderate_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_moderate_cq>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_moderate_cq>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_period as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_period)
        )
    );
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_modify_cq_attr {
    pub attr_mask: u32,
    pub moderate: ibv_moderate_cq,
}
#[test]
fn bindgen_test_layout_ibv_modify_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_modify_cq_attr>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_modify_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).moderate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(moderate)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_ah() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ah>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_ah))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ah>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ah))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_ah {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_ALLOW_LOOP_BACK: ibv_flow_flags = ibv_flow_flags(1);
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_DONT_TRAP: ibv_flow_flags = ibv_flow_flags(2);
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_EGRESS: ibv_flow_flags = ibv_flow_flags(4);
}
impl ::std::ops::BitOr<ibv_flow_flags> for ibv_flow_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_flow_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_flow_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_flow_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_flow_flags> for ibv_flow_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_flow_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_flow_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_flow_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_flow_flags(pub ::std::os::raw::c_uint);
pub mod ibv_flow_attr_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_FLOW_ATTR_NORMAL: Type = 0;
    pub const IBV_FLOW_ATTR_ALL_DEFAULT: Type = 1;
    pub const IBV_FLOW_ATTR_MC_DEFAULT: Type = 2;
    pub const IBV_FLOW_ATTR_SNIFFER: Type = 3;
}
pub mod ibv_flow_spec_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_FLOW_SPEC_ETH: Type = 32;
    pub const IBV_FLOW_SPEC_IPV4: Type = 48;
    pub const IBV_FLOW_SPEC_IPV6: Type = 49;
    pub const IBV_FLOW_SPEC_IPV4_EXT: Type = 50;
    pub const IBV_FLOW_SPEC_ESP: Type = 52;
    pub const IBV_FLOW_SPEC_TCP: Type = 64;
    pub const IBV_FLOW_SPEC_UDP: Type = 65;
    pub const IBV_FLOW_SPEC_VXLAN_TUNNEL: Type = 80;
    pub const IBV_FLOW_SPEC_GRE: Type = 81;
    pub const IBV_FLOW_SPEC_MPLS: Type = 96;
    pub const IBV_FLOW_SPEC_INNER: Type = 256;
    pub const IBV_FLOW_SPEC_ACTION_TAG: Type = 4096;
    pub const IBV_FLOW_SPEC_ACTION_DROP: Type = 4097;
    pub const IBV_FLOW_SPEC_ACTION_HANDLE: Type = 4098;
    pub const IBV_FLOW_SPEC_ACTION_COUNT: Type = 4099;
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_eth_filter {
    pub dst_mac: [u8; 6usize],
    pub src_mac: [u8; 6usize],
    pub ether_type: u16,
    pub vlan_tag: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_eth_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_eth_filter>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_eth_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).dst_mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(dst_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).src_mac as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(src_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).vlan_tag as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(vlan_tag)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_eth {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_eth_filter,
    pub mask: ibv_flow_eth_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_eth() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_eth>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_eth>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).mask as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_eth {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv4_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(dst_ip)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv4_filter,
    pub mask: ibv_flow_ipv4_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv4 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv4_ext_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_ext_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_ext_filter>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_ext_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).proto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).tos as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).ttl as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).flags as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv4_ext {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv4_ext_filter,
    pub mask: ibv_flow_ipv4_ext_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4_ext() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4_ext>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv4_ext {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_ipv6_filter {
    pub src_ip: [u8; 16usize],
    pub dst_ip: [u8; 16usize],
    pub flow_label: u32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv6_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv6_filter>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv6_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).flow_label as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).next_hdr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).traffic_class as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).hop_limit as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(hop_limit)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_ipv6 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv6_filter,
    pub mask: ibv_flow_ipv6_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv6>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv6>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).mask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_ipv6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_esp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_esp_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_esp_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_esp {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_esp_filter,
    pub mask: ibv_flow_esp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_esp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_esp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_esp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_tcp_udp_filter {
    pub dst_port: u16,
    pub src_port: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_tcp_udp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tcp_udp_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tcp_udp_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).dst_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).src_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(src_port)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tcp_udp {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_tcp_udp_filter,
    pub mask: ibv_flow_tcp_udp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tcp_udp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tcp_udp>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tcp_udp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).mask as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_tcp_udp {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_gre_filter {
    pub c_ks_res0_ver: u16,
    pub protocol: u16,
    pub key: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_gre_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_gre_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_gre_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_gre_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_gre_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_gre_filter>())).c_ks_res0_ver as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(c_ks_res0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_gre_filter>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_gre_filter>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_gre {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_gre_filter,
    pub mask: ibv_flow_gre_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_gre() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_gre>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_gre))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_gre>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_gre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_gre {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_mpls_filter {
    pub label: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_mpls_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_mpls_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_mpls_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_mpls_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_mpls_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_mpls_filter>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_mpls_filter),
            "::",
            stringify!(label)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_mpls {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_mpls_filter,
    pub mask: ibv_flow_mpls_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_mpls() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_mpls>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_mpls>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_mpls {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_flow_tunnel_filter {
    pub tunnel_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_tunnel_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tunnel_filter>())).tunnel_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tunnel_filter),
            "::",
            stringify!(tunnel_id)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_tunnel {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_tunnel_filter,
    pub mask: ibv_flow_tunnel_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tunnel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tunnel>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(mask)
        )
    );
}
impl Default for ibv_flow_spec_tunnel {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_tag {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub tag_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_tag() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_tag>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).tag_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(tag_id)
        )
    );
}
impl Default for ibv_flow_spec_action_tag {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_drop {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_drop() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_drop>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_drop>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(size)
        )
    );
}
impl Default for ibv_flow_spec_action_drop {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_action_handle {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub action: *const ibv_flow_action,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_handle() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_handle>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).action as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(action)
        )
    );
}
impl Default for ibv_flow_spec_action_handle {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec_counter_action {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub counters: *mut ibv_counters,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_counter_action() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_counter_action>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_counter_action))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_counter_action>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_counter_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).counters as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(counters)
        )
    );
}
impl Default for ibv_flow_spec_counter_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec {
    pub __bindgen_anon_1: ibv_flow_spec__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union ibv_flow_spec__bindgen_ty_1 {
    pub hdr: ibv_flow_spec__bindgen_ty_1__bindgen_ty_1,
    pub eth: ibv_flow_spec_eth,
    pub ipv4: ibv_flow_spec_ipv4,
    pub tcp_udp: ibv_flow_spec_tcp_udp,
    pub ipv4_ext: ibv_flow_spec_ipv4_ext,
    pub ipv6: ibv_flow_spec_ipv6,
    pub esp: ibv_flow_spec_esp,
    pub tunnel: ibv_flow_spec_tunnel,
    pub gre: ibv_flow_spec_gre,
    pub mpls: ibv_flow_spec_mpls,
    pub flow_tag: ibv_flow_spec_action_tag,
    pub drop: ibv_flow_spec_action_drop,
    pub handle: ibv_flow_spec_action_handle,
    pub flow_count: ibv_flow_spec_counter_action,
    _bindgen_union_align: [u64; 11usize],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
impl Default for ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).eth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tcp_udp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tcp_udp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4_ext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).esp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tunnel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tunnel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).gre as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(gre)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).mpls as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(mpls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).flow_tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(flow_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).drop as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).flow_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(flow_count)
        )
    );
}
impl Default for ibv_flow_spec__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_ibv_flow_spec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec))
    );
}
impl Default for ibv_flow_spec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub type_: ibv_flow_attr_type::Type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).priority as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).num_of_specs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(num_of_specs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).port as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ibv_flow_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(handle)
        )
    );
}
impl Default for ibv_flow {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_flow_action() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_flow_action {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_flow_action_esp_mask {
    pub const IBV_FLOW_ACTION_ESP_MASK_ESN: ibv_flow_action_esp_mask = ibv_flow_action_esp_mask(1);
}
impl ::std::ops::BitOr<ibv_flow_action_esp_mask> for ibv_flow_action_esp_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_flow_action_esp_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_flow_action_esp_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_flow_action_esp_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_flow_action_esp_mask> for ibv_flow_action_esp_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_flow_action_esp_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_flow_action_esp_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_flow_action_esp_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_flow_action_esp_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_flow_action_esp_attr {
    pub esp_attr: *mut ib_uverbs_flow_action_esp,
    pub keymat_proto: ib_uverbs_flow_action_esp_keymat,
    pub keymat_len: u16,
    pub keymat_ptr: *mut ::std::os::raw::c_void,
    pub replay_proto: ib_uverbs_flow_action_esp_replay,
    pub replay_len: u16,
    pub replay_ptr: *mut ::std::os::raw::c_void,
    pub esp_encap: *mut ib_uverbs_flow_action_esp_encap,
    pub comp_mask: u32,
    pub esn: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_action_esp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action_esp_attr>(),
        56usize,
        concat!("Size of: ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action_esp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_proto as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_proto as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_len as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_ptr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_encap as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_encap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).comp_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esn as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esn)
        )
    );
}
impl Default for ibv_flow_action_esp_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[test]
fn bindgen_test_layout__ibv_device_ops() {
    assert_eq!(
        ::std::mem::size_of::<_ibv_device_ops>(),
        16usize,
        concat!("Size of: ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibv_device_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type::Type,
    pub transport_type: ibv_transport_type::Type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_ibv_device() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device>(),
        664usize,
        concat!("Size of: ", stringify!(ibv_device))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>()))._ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).node_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(node_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).transport_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(transport_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_path as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).ibdev_path as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(ibdev_path)
        )
    );
}
impl Default for ibv_device {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type::Type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_ibv_context_ops() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context_ops>(),
        256usize,
        concat!("Size of: ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_port as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_alloc_pd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_alloc_pd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_dealloc_pd as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_dealloc_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>()))._compat_reg_mr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_reg_mr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_rereg_mr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_rereg_mr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_dereg_mr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_dereg_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).alloc_mw as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(alloc_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).bind_mw as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).dealloc_mw as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(dealloc_mw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_cq as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).poll_cq as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(poll_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).req_notify_cq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(req_notify_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_cq_event as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_cq_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_resize_cq as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_resize_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_cq as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_srq as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_modify_srq as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_modify_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_srq as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_srq as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_srq_recv as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_srq_recv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_qp as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_qp as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_modify_qp as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_modify_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_qp as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_send as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_recv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_ah as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_ah as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_attach_mcast as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_attach_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_detach_mcast as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_detach_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_async_event as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_async_event)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ibv_context() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context>(),
        328usize,
        concat!("Size of: ", stringify!(ibv_context))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).cmd_fd as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(cmd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).async_fd as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(async_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).num_comp_vectors as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(num_comp_vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).mutex as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).abi_compat as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(abi_compat)
        )
    );
}
impl Default for ibv_context {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_cq_init_attr_mask {
    pub const IBV_CQ_INIT_ATTR_MASK_FLAGS: ibv_cq_init_attr_mask = ibv_cq_init_attr_mask(1);
}
impl ::std::ops::BitOr<ibv_cq_init_attr_mask> for ibv_cq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_cq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_cq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_cq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_cq_init_attr_mask> for ibv_cq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_cq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_cq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_cq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_cq_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_create_cq_attr_flags {
    pub const IBV_CREATE_CQ_ATTR_SINGLE_THREADED: ibv_create_cq_attr_flags =
        ibv_create_cq_attr_flags(1);
}
impl ibv_create_cq_attr_flags {
    pub const IBV_CREATE_CQ_ATTR_IGNORE_OVERRUN: ibv_create_cq_attr_flags =
        ibv_create_cq_attr_flags(2);
}
impl ::std::ops::BitOr<ibv_create_cq_attr_flags> for ibv_create_cq_attr_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_create_cq_attr_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_create_cq_attr_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_create_cq_attr_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_create_cq_attr_flags> for ibv_create_cq_attr_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_create_cq_attr_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_create_cq_attr_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_create_cq_attr_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_create_cq_attr_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_init_attr_ex>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cqe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).channel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_vector as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).wc_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(flags)
        )
    );
}
impl Default for ibv_cq_init_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_parent_domain_init_attr_mask {
    pub const IBV_PARENT_DOMAIN_INIT_ATTR_ALLOCATORS: ibv_parent_domain_init_attr_mask =
        ibv_parent_domain_init_attr_mask(1);
}
impl ibv_parent_domain_init_attr_mask {
    pub const IBV_PARENT_DOMAIN_INIT_ATTR_PD_CONTEXT: ibv_parent_domain_init_attr_mask =
        ibv_parent_domain_init_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_parent_domain_init_attr_mask> for ibv_parent_domain_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_parent_domain_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_parent_domain_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_parent_domain_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_parent_domain_init_attr_mask> for ibv_parent_domain_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_parent_domain_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_parent_domain_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_parent_domain_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_parent_domain_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_parent_domain_init_attr {
    pub pd: *mut ibv_pd,
    pub td: *mut ibv_td,
    pub comp_mask: u32,
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            size: size_t,
            alignment: size_t,
            resource_type: u64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            resource_type: u64,
        ),
    >,
    pub pd_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ibv_parent_domain_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_parent_domain_init_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_parent_domain_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).td as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).alloc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).free as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).pd_context as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(pd_context)
        )
    );
}
impl Default for ibv_parent_domain_init_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_counters_init_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_counters_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counters_init_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_counters_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counters_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_counters_init_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counters_init_attr>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counters_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_counters {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_counters() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counters>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_counters))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counters>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_counters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_counters>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counters),
            "::",
            stringify!(context)
        )
    );
}
impl Default for ibv_counters {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub mod ibv_counter_description {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_COUNTER_PACKETS: Type = 0;
    pub const IBV_COUNTER_BYTES: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ibv_counter_attach_attr {
    pub counter_desc: ibv_counter_description::Type,
    pub index: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_counter_attach_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counter_attach_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_counter_attach_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counter_attach_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_counter_attach_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counter_attach_attr>())).counter_desc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(counter_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_counter_attach_attr>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counter_attach_attr>())).comp_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl Default for ibv_counter_attach_attr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
impl ibv_read_counters_flags {
    pub const IBV_READ_COUNTERS_ATTR_PREFER_CACHED: ibv_read_counters_flags =
        ibv_read_counters_flags(1);
}
impl ::std::ops::BitOr<ibv_read_counters_flags> for ibv_read_counters_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_read_counters_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_read_counters_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_read_counters_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_read_counters_flags> for ibv_read_counters_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_read_counters_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_read_counters_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_read_counters_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_read_counters_flags(pub ::std::os::raw::c_uint);
impl ibv_values_mask {
    pub const IBV_VALUES_MASK_RAW_CLOCK: ibv_values_mask = ibv_values_mask(1);
}
impl ibv_values_mask {
    pub const IBV_VALUES_MASK_RESERVED: ibv_values_mask = ibv_values_mask(2);
}
impl ::std::ops::BitOr<ibv_values_mask> for ibv_values_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_values_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_values_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_values_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_values_mask> for ibv_values_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_values_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_values_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_values_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Debug, Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_values_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: timespec,
}
#[test]
fn bindgen_test_layout_ibv_values_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_values_ex>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_values_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).raw_clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(raw_clock)
        )
    );
}
extern "C" {
    #[doc = " ibv_get_device_list - Get list of IB devices currently available"]
    #[doc = " @num_devices: optional.  if non-NULL, set to the number of devices"]
    #[doc = " returned in the array."]
    #[doc = ""]
    #[doc = " Return a NULL-terminated array of IB devices.  The array can be"]
    #[doc = " released with ibv_free_device_list()."]
    pub fn ibv_get_device_list(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_device;
}
extern "C" {
    #[doc = " ibv_free_device_list - Free list from ibv_get_device_list()"]
    #[doc = ""]
    #[doc = " Free an array of devices returned from ibv_get_device_list().  Once"]
    #[doc = " the array is freed, pointers to devices that were not opened with"]
    #[doc = " ibv_open_device() are no longer valid.  Client code must open all"]
    #[doc = " devices it intends to use before calling ibv_free_device_list()."]
    pub fn ibv_free_device_list(list: *mut *mut ibv_device);
}
extern "C" {
    #[doc = " ibv_get_device_name - Return kernel device name"]
    pub fn ibv_get_device_name(device: *mut ibv_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_get_device_guid - Return device's node GUID"]
    pub fn ibv_get_device_guid(device: *mut ibv_device) -> __be64;
}
extern "C" {
    #[doc = " ibv_open_device - Initialize device for use"]
    pub fn ibv_open_device(device: *mut ibv_device) -> *mut ibv_context;
}
extern "C" {
    #[doc = " ibv_close_device - Release device"]
    pub fn ibv_close_device(context: *mut ibv_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_async_event - Get next async event"]
    #[doc = " @event: Pointer to use to return async event"]
    #[doc = ""]
    #[doc = " All async events returned by ibv_get_async_event() must eventually"]
    #[doc = " be acknowledged with ibv_ack_async_event()."]
    pub fn ibv_get_async_event(
        context: *mut ibv_context,
        event: *mut ibv_async_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_ack_async_event - Acknowledge an async event"]
    #[doc = " @event: Event to be acknowledged."]
    #[doc = ""]
    #[doc = " All async events which are returned by ibv_get_async_event() must"]
    #[doc = " be acknowledged.  To avoid races, destroying an object (CQ, SRQ or"]
    #[doc = " QP) will wait for all affiliated events to be acknowledged, so"]
    #[doc = " there should be a one-to-one correspondence between acks and"]
    #[doc = " successful gets."]
    pub fn ibv_ack_async_event(event: *mut ibv_async_event);
}
extern "C" {
    #[doc = " ibv_query_device - Get device properties"]
    pub fn ibv_query_device(
        context: *mut ibv_context,
        device_attr: *mut ibv_device_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_port - Get port properties"]
    pub fn ibv_query_port(
        context: *mut ibv_context,
        port_num: u8,
        port_attr: *mut _compat_ibv_port_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_gid - Get a GID table entry"]
    pub fn ibv_query_gid(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        gid: *mut ibv_gid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_pkey - Get a P_Key table entry"]
    pub fn ibv_query_pkey(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        pkey: *mut __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_pkey_index - Translate a P_Key into a P_Key index"]
    pub fn ibv_get_pkey_index(
        context: *mut ibv_context,
        port_num: u8,
        pkey: __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_alloc_pd - Allocate a protection domain"]
    pub fn ibv_alloc_pd(context: *mut ibv_context) -> *mut ibv_pd;
}
extern "C" {
    #[doc = " ibv_dealloc_pd - Free a protection domain"]
    pub fn ibv_dealloc_pd(pd: *mut ibv_pd) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_reg_mr_iova2 - Register memory region with a virtual offset address"]
    #[doc = ""]
    #[doc = " This version will be called if ibv_reg_mr or ibv_reg_mr_iova were called"]
    #[doc = " with at least one potential access flag from the IBV_OPTIONAL_ACCESS_RANGE"]
    #[doc = " flags range The optional access flags will be masked if running over kernel"]
    #[doc = " that does not support passing them."]
    pub fn ibv_reg_mr_iova2(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: size_t,
        iova: u64,
        access: ::std::os::raw::c_uint,
    ) -> *mut ibv_mr;
}
extern "C" {
    #[doc = " ibv_reg_mr - Register a memory region"]
    pub fn ibv_reg_mr(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: size_t,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
extern "C" {
    #[doc = " ibv_reg_mr_iova - Register a memory region with a virtual offset"]
    #[doc = " address"]
    pub fn ibv_reg_mr_iova(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: size_t,
        iova: u64,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
pub mod ibv_rereg_mr_err_code {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_REREG_MR_ERR_INPUT: Type = -1;
    pub const IBV_REREG_MR_ERR_DONT_FORK_NEW: Type = -2;
    pub const IBV_REREG_MR_ERR_DO_FORK_OLD: Type = -3;
    pub const IBV_REREG_MR_ERR_CMD: Type = -4;
    pub const IBV_REREG_MR_ERR_CMD_AND_DO_FORK_NEW: Type = -5;
}
extern "C" {
    #[doc = " ibv_rereg_mr - Re-Register a memory region"]
    pub fn ibv_rereg_mr(
        mr: *mut ibv_mr,
        flags: ::std::os::raw::c_int,
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: size_t,
        access: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_dereg_mr - Deregister a memory region"]
    pub fn ibv_dereg_mr(mr: *mut ibv_mr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_comp_channel - Create a completion event channel"]
    pub fn ibv_create_comp_channel(context: *mut ibv_context) -> *mut ibv_comp_channel;
}
extern "C" {
    #[doc = " ibv_destroy_comp_channel - Destroy a completion event channel"]
    pub fn ibv_destroy_comp_channel(channel: *mut ibv_comp_channel) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_cq - Create a completion queue"]
    #[doc = " @context - Context CQ will be attached to"]
    #[doc = " @cqe - Minimum number of entries required for CQ"]
    #[doc = " @cq_context - Consumer-supplied context returned for completion events"]
    #[doc = " @channel - Completion channel where completion events will be queued."]
    #[doc = "     May be NULL if completion events will not be used."]
    #[doc = " @comp_vector - Completion vector used to signal completion events."]
    #[doc = "     Must be >= 0 and < context->num_comp_vectors."]
    pub fn ibv_create_cq(
        context: *mut ibv_context,
        cqe: ::std::os::raw::c_int,
        cq_context: *mut ::std::os::raw::c_void,
        channel: *mut ibv_comp_channel,
        comp_vector: ::std::os::raw::c_int,
    ) -> *mut ibv_cq;
}
extern "C" {
    #[doc = " ibv_resize_cq - Modifies the capacity of the CQ."]
    #[doc = " @cq: The CQ to resize."]
    #[doc = " @cqe: The minimum size of the CQ."]
    #[doc = ""]
    #[doc = " Users can examine the cq structure to determine the actual CQ size."]
    pub fn ibv_resize_cq(cq: *mut ibv_cq, cqe: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_cq - Destroy a completion queue"]
    pub fn ibv_destroy_cq(cq: *mut ibv_cq) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_get_cq_event - Read next CQ event"]
    #[doc = " @channel: Channel to get next event from."]
    #[doc = " @cq: Used to return pointer to CQ."]
    #[doc = " @cq_context: Used to return consumer-supplied CQ context."]
    #[doc = ""]
    #[doc = " All completion events returned by ibv_get_cq_event() must"]
    #[doc = " eventually be acknowledged with ibv_ack_cq_events()."]
    pub fn ibv_get_cq_event(
        channel: *mut ibv_comp_channel,
        cq: *mut *mut ibv_cq,
        cq_context: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_ack_cq_events - Acknowledge CQ completion events"]
    #[doc = " @cq: CQ to acknowledge events for"]
    #[doc = " @nevents: Number of events to acknowledge."]
    #[doc = ""]
    #[doc = " All completion events which are returned by ibv_get_cq_event() must"]
    #[doc = " be acknowledged.  To avoid races, ibv_destroy_cq() will wait for"]
    #[doc = " all completion events to be acknowledged, so there should be a"]
    #[doc = " one-to-one correspondence between acks and successful gets.  An"]
    #[doc = " application may accumulate multiple completion events and"]
    #[doc = " acknowledge them in a single call to ibv_ack_cq_events() by passing"]
    #[doc = " the number of events to ack in @nevents."]
    pub fn ibv_ack_cq_events(cq: *mut ibv_cq, nevents: ::std::os::raw::c_uint);
}
extern "C" {
    #[doc = " ibv_create_srq - Creates a SRQ associated with the specified protection"]
    #[doc = "   domain."]
    #[doc = " @pd: The protection domain associated with the SRQ."]
    #[doc = " @srq_init_attr: A list of initial attributes required to create the SRQ."]
    #[doc = ""]
    #[doc = " srq_attr->max_wr and srq_attr->max_sge are read the determine the"]
    #[doc = " requested size of the SRQ, and set to the actual values allocated"]
    #[doc = " on return.  If ibv_create_srq() succeeds, then max_wr and max_sge"]
    #[doc = " will always be at least as large as the requested values."]
    pub fn ibv_create_srq(pd: *mut ibv_pd, srq_init_attr: *mut ibv_srq_init_attr) -> *mut ibv_srq;
}
extern "C" {
    #[doc = " ibv_modify_srq - Modifies the attributes for the specified SRQ."]
    #[doc = " @srq: The SRQ to modify."]
    #[doc = " @srq_attr: On input, specifies the SRQ attributes to modify.  On output,"]
    #[doc = "   the current values of selected SRQ attributes are returned."]
    #[doc = " @srq_attr_mask: A bit-mask used to specify which attributes of the SRQ"]
    #[doc = "   are being modified."]
    #[doc = ""]
    #[doc = " The mask may contain IBV_SRQ_MAX_WR to resize the SRQ and/or"]
    #[doc = " IBV_SRQ_LIMIT to set the SRQ's limit and request notification when"]
    #[doc = " the number of receives queued drops below the limit."]
    pub fn ibv_modify_srq(
        srq: *mut ibv_srq,
        srq_attr: *mut ibv_srq_attr,
        srq_attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_srq - Returns the attribute list and current values for the"]
    #[doc = "   specified SRQ."]
    #[doc = " @srq: The SRQ to query."]
    #[doc = " @srq_attr: The attributes of the specified SRQ."]
    pub fn ibv_query_srq(srq: *mut ibv_srq, srq_attr: *mut ibv_srq_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_srq - Destroys the specified SRQ."]
    #[doc = " @srq: The SRQ to destroy."]
    pub fn ibv_destroy_srq(srq: *mut ibv_srq) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_qp - Create a queue pair."]
    pub fn ibv_create_qp(pd: *mut ibv_pd, qp_init_attr: *mut ibv_qp_init_attr) -> *mut ibv_qp;
}
extern "C" {
    #[doc = " ibv_modify_qp - Modify a queue pair."]
    pub fn ibv_modify_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_query_qp - Returns the attribute list and current values for the"]
    #[doc = "   specified QP."]
    #[doc = " @qp: The QP to query."]
    #[doc = " @attr: The attributes of the specified QP."]
    #[doc = " @attr_mask: A bit-mask used to select specific attributes to query."]
    #[doc = " @init_attr: Additional attributes of the selected QP."]
    #[doc = ""]
    #[doc = " The qp_attr_mask may be used to limit the query to gathering only the"]
    #[doc = " selected attributes."]
    pub fn ibv_query_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
        init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_destroy_qp - Destroy a queue pair."]
    pub fn ibv_destroy_qp(qp: *mut ibv_qp) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_ah - Create an address handle."]
    pub fn ibv_create_ah(pd: *mut ibv_pd, attr: *mut ibv_ah_attr) -> *mut ibv_ah;
}
extern "C" {
    #[doc = " ibv_init_ah_from_wc - Initializes address handle attributes from a"]
    #[doc = "   work completion."]
    #[doc = " @context: Device context on which the received message arrived."]
    #[doc = " @port_num: Port on which the received message arrived."]
    #[doc = " @wc: Work completion associated with the received message."]
    #[doc = " @grh: References the received global route header.  This parameter is"]
    #[doc = "   ignored unless the work completion indicates that the GRH is valid."]
    #[doc = " @ah_attr: Returned attributes that can be used when creating an address"]
    #[doc = "   handle for replying to the message."]
    pub fn ibv_init_ah_from_wc(
        context: *mut ibv_context,
        port_num: u8,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        ah_attr: *mut ibv_ah_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_create_ah_from_wc - Creates an address handle associated with the"]
    #[doc = "   sender of the specified work completion."]
    #[doc = " @pd: The protection domain associated with the address handle."]
    #[doc = " @wc: Work completion information associated with a received message."]
    #[doc = " @grh: References the received global route header.  This parameter is"]
    #[doc = "   ignored unless the work completion indicates that the GRH is valid."]
    #[doc = " @port_num: The outbound port number to associate with the address."]
    #[doc = ""]
    #[doc = " The address handle is used to reference a local or global destination"]
    #[doc = " in all UD QP post sends."]
    pub fn ibv_create_ah_from_wc(
        pd: *mut ibv_pd,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        port_num: u8,
    ) -> *mut ibv_ah;
}
extern "C" {
    #[doc = " ibv_destroy_ah - Destroy an address handle."]
    pub fn ibv_destroy_ah(ah: *mut ibv_ah) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_attach_mcast - Attaches the specified QP to a multicast group."]
    #[doc = " @qp: QP to attach to the multicast group.  The QP must be a UD QP."]
    #[doc = " @gid: Multicast group GID."]
    #[doc = " @lid: Multicast group LID in host byte order."]
    #[doc = ""]
    #[doc = " In order to route multicast packets correctly, subnet"]
    #[doc = " administration must have created the multicast group and configured"]
    #[doc = " the fabric appropriately.  The port associated with the specified"]
    #[doc = " QP must also be a member of the multicast group."]
    pub fn ibv_attach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_detach_mcast - Detaches the specified QP from a multicast group."]
    #[doc = " @qp: QP to detach from the multicast group."]
    #[doc = " @gid: Multicast group GID."]
    #[doc = " @lid: Multicast group LID in host byte order."]
    pub fn ibv_detach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_fork_init - Prepare data structures so that fork() may be used"]
    #[doc = " safely.  If this function is not called or returns a non-zero"]
    #[doc = " status, then libibverbs data structures are not fork()-safe and the"]
    #[doc = " effect of an application calling fork() is undefined."]
    pub fn ibv_fork_init() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " ibv_node_type_str - Return string describing node_type enum value"]
    pub fn ibv_node_type_str(node_type: ibv_node_type::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_port_state_str - Return string describing port_state enum value"]
    pub fn ibv_port_state_str(port_state: ibv_port_state::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " ibv_event_type_str - Return string describing event_type enum value"]
    pub fn ibv_event_type_str(event: ibv_event_type::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_resolve_eth_l2_from_gid(
        context: *mut ibv_context,
        attr: *mut ibv_ah_attr,
        eth_mac: *mut u8,
        vid: *mut u16,
    ) -> ::std::os::raw::c_int;
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr {
    pub sa_family: sa_family_t,
    pub sa_data: [::std::os::raw::c_char; 14usize],
}
#[test]
fn bindgen_test_layout_sockaddr() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr>(),
        2usize,
        concat!("Alignment of ", stringify!(sockaddr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr>())).sa_data as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr),
            "::",
            stringify!(sa_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_storage {
    pub ss_family: sa_family_t,
    pub __ss_padding: [::std::os::raw::c_char; 118usize],
    pub __ss_align: ::std::os::raw::c_ulong,
}
#[test]
fn bindgen_test_layout_sockaddr_storage() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_storage>(),
        128usize,
        concat!("Size of: ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_storage>(),
        8usize,
        concat!("Alignment of ", stringify!(sockaddr_storage))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).ss_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(ss_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_padding as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_storage>())).__ss_align as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_storage),
            "::",
            stringify!(__ss_align)
        )
    );
}
impl Default for sockaddr_storage {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union in6_addr__bindgen_ty_1 {
    pub __u6_addr8: [u8; 16usize],
    pub __u6_addr16: [u16; 8usize],
    pub __u6_addr32: [u32; 4usize],
    _bindgen_union_align: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
impl Default for in6_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
impl Default for in6_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct sockaddr_in {
    pub sin_family: sa_family_t,
    pub sin_port: in_port_t,
    pub sin_addr: in_addr,
    pub sin_zero: [::std::os::raw::c_uchar; 8usize],
}
#[test]
fn bindgen_test_layout_sockaddr_in() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in>(),
        16usize,
        concat!("Size of: ", stringify!(sockaddr_in))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_addr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in>())).sin_zero as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in),
            "::",
            stringify!(sin_zero)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct sockaddr_in6 {
    pub sin6_family: sa_family_t,
    pub sin6_port: in_port_t,
    pub sin6_flowinfo: u32,
    pub sin6_addr: in6_addr,
    pub sin6_scope_id: u32,
}
#[test]
fn bindgen_test_layout_sockaddr_in6() {
    assert_eq!(
        ::std::mem::size_of::<sockaddr_in6>(),
        28usize,
        concat!("Size of: ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        ::std::mem::align_of::<sockaddr_in6>(),
        4usize,
        concat!("Alignment of ", stringify!(sockaddr_in6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_family as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_port as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_flowinfo as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_flowinfo)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<sockaddr_in6>())).sin6_scope_id as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(sockaddr_in6),
            "::",
            stringify!(sin6_scope_id)
        )
    );
}
impl Default for sockaddr_in6 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_path_rec {
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub raw_traffic: ::std::os::raw::c_int,
    pub flow_label: __be32,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reversible: ::std::os::raw::c_int,
    pub numb_path: u8,
    pub pkey: __be16,
    pub sl: u8,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub preference: u8,
}
#[test]
fn bindgen_test_layout_ibv_sa_path_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_path_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_path_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dlid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).slid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).raw_traffic as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(raw_traffic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).flow_label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).hop_limit as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).traffic_class as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).reversible as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(reversible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).numb_path as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(numb_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).pkey as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu_selector as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate_selector as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time_selector as *const _
                as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).preference as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(preference)
        )
    );
}
impl Default for ibv_sa_path_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_mcmember_rec {
    pub mgid: ibv_gid,
    pub port_gid: ibv_gid,
    pub qkey: u32,
    pub mlid: u16,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub traffic_class: u8,
    pub pkey: u16,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub sl: u8,
    pub flow_label: u32,
    pub hop_limit: u8,
    pub scope: u8,
    pub join_state: u8,
    pub proxy_join: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_sa_mcmember_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_mcmember_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_mcmember_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).port_gid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(port_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).qkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mlid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mlid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu_selector as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).traffic_class as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).pkey as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate_selector as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time_selector as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time as *const _ as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).sl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).flow_label as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).hop_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).scope as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).join_state as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(join_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).proxy_join as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(proxy_join)
        )
    );
}
impl Default for ibv_sa_mcmember_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sa_service_rec {
    pub id: u64,
    pub gid: ibv_gid,
    pub pkey: u16,
    pub lease: u32,
    pub key: [u8; 16usize],
    pub name: [u8; 64usize],
    pub data8: [u8; 16usize],
    pub data16: [u16; 8usize],
    pub data32: [u32; 4usize],
    pub data64: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ibv_sa_service_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_service_rec>(),
        176usize,
        concat!("Size of: ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_service_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).lease as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(lease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data8 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data16 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data32 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data64 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data64)
        )
    );
}
impl Default for ibv_sa_service_rec {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_record {
    pub service_id: __be64,
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub flowlabel_hoplimit: __be32,
    pub tclass: u8,
    pub reversible_numpath: u8,
    pub pkey: __be16,
    pub qosclass_sl: __be16,
    pub mtu: u8,
    pub rate: u8,
    pub packetlifetime: u8,
    pub preference: u8,
    pub reserved: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ibv_path_record() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_record>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_path_record))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_record>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).service_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).sgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dlid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).slid as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).flowlabel_hoplimit as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(flowlabel_hoplimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).tclass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(tclass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).reversible_numpath as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reversible_numpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).pkey as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).qosclass_sl as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(qosclass_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).mtu as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).rate as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).packetlifetime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(packetlifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).preference as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(preference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).reserved as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reserved)
        )
    );
}
impl Default for ibv_path_record {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_path_data {
    pub flags: u32,
    pub reserved: u32,
    pub path: ibv_path_record,
}
#[test]
fn bindgen_test_layout_ibv_path_data() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_data>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_path_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(path)
        )
    );
}
impl Default for ibv_path_data {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const RDMA_CM_EVENT_ADDR_RESOLVED: rdma_cm_event_type = 0;
pub const RDMA_CM_EVENT_ADDR_ERROR: rdma_cm_event_type = 1;
pub const RDMA_CM_EVENT_ROUTE_RESOLVED: rdma_cm_event_type = 2;
pub const RDMA_CM_EVENT_ROUTE_ERROR: rdma_cm_event_type = 3;
pub const RDMA_CM_EVENT_CONNECT_REQUEST: rdma_cm_event_type = 4;
pub const RDMA_CM_EVENT_CONNECT_RESPONSE: rdma_cm_event_type = 5;
pub const RDMA_CM_EVENT_CONNECT_ERROR: rdma_cm_event_type = 6;
pub const RDMA_CM_EVENT_UNREACHABLE: rdma_cm_event_type = 7;
pub const RDMA_CM_EVENT_REJECTED: rdma_cm_event_type = 8;
pub const RDMA_CM_EVENT_ESTABLISHED: rdma_cm_event_type = 9;
pub const RDMA_CM_EVENT_DISCONNECTED: rdma_cm_event_type = 10;
pub const RDMA_CM_EVENT_DEVICE_REMOVAL: rdma_cm_event_type = 11;
pub const RDMA_CM_EVENT_MULTICAST_JOIN: rdma_cm_event_type = 12;
pub const RDMA_CM_EVENT_MULTICAST_ERROR: rdma_cm_event_type = 13;
pub const RDMA_CM_EVENT_ADDR_CHANGE: rdma_cm_event_type = 14;
pub const RDMA_CM_EVENT_TIMEWAIT_EXIT: rdma_cm_event_type = 15;
pub type rdma_cm_event_type = ::std::os::raw::c_uint;
pub const RDMA_PS_IPOIB: rdma_port_space = 2;
pub const RDMA_PS_TCP: rdma_port_space = 262;
pub const RDMA_PS_UDP: rdma_port_space = 273;
pub const RDMA_PS_IB: rdma_port_space = 319;
pub type rdma_port_space = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ib_addr {
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
    pub pkey: __be16,
}
#[test]
fn bindgen_test_layout_rdma_ib_addr() {
    assert_eq!(
        ::std::mem::size_of::<rdma_ib_addr>(),
        40usize,
        concat!("Size of: ", stringify!(rdma_ib_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_ib_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_ib_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).sgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).dgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ib_addr>())).pkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ib_addr),
            "::",
            stringify!(pkey)
        )
    );
}
impl Default for rdma_ib_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_addr {
    pub __bindgen_anon_1: rdma_addr__bindgen_ty_1,
    pub __bindgen_anon_2: rdma_addr__bindgen_ty_2,
    pub addr: rdma_addr__bindgen_ty_3,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_1 {
    pub src_addr: sockaddr,
    pub src_sin: sockaddr_in,
    pub src_sin6: sockaddr_in6,
    pub src_storage: sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_storage)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_2 {
    pub dst_addr: sockaddr,
    pub dst_sin: sockaddr_in,
    pub dst_sin6: sockaddr_in6,
    pub dst_storage: sockaddr_storage,
    _bindgen_union_align: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_2>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_storage)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_2 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_addr__bindgen_ty_3 {
    pub ibaddr: rdma_ib_addr,
    _bindgen_union_align: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_3>())).ibaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_3),
            "::",
            stringify!(ibaddr)
        )
    );
}
impl Default for rdma_addr__bindgen_ty_3 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rdma_addr() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr>(),
        296usize,
        concat!("Size of: ", stringify!(rdma_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr>())).addr as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rdma_addr {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_route {
    pub addr: rdma_addr,
    pub path_rec: *mut ibv_sa_path_rec,
    pub num_paths: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_route() {
    assert_eq!(
        ::std::mem::size_of::<rdma_route>(),
        312usize,
        concat!("Size of: ", stringify!(rdma_route))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_route>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_route))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).path_rec as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(path_rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).num_paths as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(num_paths)
        )
    );
}
impl Default for rdma_route {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Default, Copy, Clone)]
pub struct rdma_event_channel {
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_event_channel() {
    assert_eq!(
        ::std::mem::size_of::<rdma_event_channel>(),
        4usize,
        concat!("Size of: ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_event_channel>(),
        4usize,
        concat!("Alignment of ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_event_channel>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_event_channel),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_id {
    pub verbs: *mut ibv_context,
    pub channel: *mut rdma_event_channel,
    pub context: *mut ::std::os::raw::c_void,
    pub qp: *mut ibv_qp,
    pub route: rdma_route,
    pub ps: rdma_port_space,
    pub port_num: u8,
    pub event: *mut rdma_cm_event,
    pub send_cq_channel: *mut ibv_comp_channel,
    pub send_cq: *mut ibv_cq,
    pub recv_cq_channel: *mut ibv_comp_channel,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub pd: *mut ibv_pd,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_rdma_cm_id() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_id>(),
        416usize,
        concat!("Size of: ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_id>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).verbs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(verbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).route as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).ps as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).port_num as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).event as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq_channel as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq_channel as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).srq as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).pd as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp_type as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp_type)
        )
    );
}
impl Default for rdma_cm_id {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_conn_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub responder_resources: u8,
    pub initiator_depth: u8,
    pub flow_control: u8,
    pub retry_count: u8,
    pub rnr_retry_count: u8,
    pub srq: u8,
    pub qp_num: u32,
}
#[test]
fn bindgen_test_layout_rdma_conn_param() {
    assert_eq!(
        ::std::mem::size_of::<rdma_conn_param>(),
        24usize,
        concat!("Size of: ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_conn_param>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).private_data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).responder_resources as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(responder_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).initiator_depth as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(initiator_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).flow_control as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).retry_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).rnr_retry_count as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(rnr_retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).srq as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).qp_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(qp_num)
        )
    );
}
impl Default for rdma_conn_param {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_ud_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub ah_attr: ibv_ah_attr,
    pub qp_num: u32,
    pub qkey: u32,
}
#[test]
fn bindgen_test_layout_rdma_ud_param() {
    assert_eq!(
        ::std::mem::size_of::<rdma_ud_param>(),
        56usize,
        concat!("Size of: ", stringify!(rdma_ud_param))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_ud_param>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_ud_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).private_data_len as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(private_data_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).ah_attr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).qp_num as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_ud_param>())).qkey as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_ud_param),
            "::",
            stringify!(qkey)
        )
    );
}
impl Default for rdma_ud_param {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_event {
    pub id: *mut rdma_cm_id,
    pub listen_id: *mut rdma_cm_id,
    pub event: rdma_cm_event_type,
    pub status: ::std::os::raw::c_int,
    pub param: rdma_cm_event__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union rdma_cm_event__bindgen_ty_1 {
    pub conn: rdma_conn_param,
    pub ud: rdma_ud_param,
    _bindgen_union_align: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rdma_cm_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_event__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).conn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(ud)
        )
    );
}
impl Default for rdma_cm_event__bindgen_ty_1 {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[test]
fn bindgen_test_layout_rdma_cm_event() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_event>(),
        80usize,
        concat!("Size of: ", stringify!(rdma_cm_event))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_event>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_event))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).listen_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(listen_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).event as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).status as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event>())).param as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event),
            "::",
            stringify!(param)
        )
    );
}
impl Default for rdma_cm_event {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_qp_type: ::std::os::raw::c_int,
    pub ai_port_space: ::std::os::raw::c_int,
    pub ai_src_len: socklen_t,
    pub ai_dst_len: socklen_t,
    pub ai_src_addr: *mut sockaddr,
    pub ai_dst_addr: *mut sockaddr,
    pub ai_src_canonname: *mut ::std::os::raw::c_char,
    pub ai_dst_canonname: *mut ::std::os::raw::c_char,
    pub ai_route_len: size_t,
    pub ai_route: *mut ::std::os::raw::c_void,
    pub ai_connect_len: size_t,
    pub ai_connect: *mut ::std::os::raw::c_void,
    pub ai_next: *mut rdma_addrinfo,
}
#[test]
fn bindgen_test_layout_rdma_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addrinfo>(),
        96usize,
        concat!("Size of: ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_qp_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_port_space as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_port_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_canonname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_canonname as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
impl Default for rdma_addrinfo {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
pub const RDMA_CM_JOIN_MC_ATTR_ADDRESS: rdma_cm_join_mc_attr_mask = 1;
pub const RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS: rdma_cm_join_mc_attr_mask = 2;
pub const RDMA_CM_JOIN_MC_ATTR_RESERVED: rdma_cm_join_mc_attr_mask = 4;
pub type rdma_cm_join_mc_attr_mask = ::std::os::raw::c_uint;
pub const RDMA_MC_JOIN_FLAG_FULLMEMBER: rdma_cm_mc_join_flags = 0;
pub const RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER: rdma_cm_mc_join_flags = 1;
pub const RDMA_MC_JOIN_FLAG_RESERVED: rdma_cm_mc_join_flags = 2;
pub type rdma_cm_mc_join_flags = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct rdma_cm_join_mc_attr_ex {
    pub comp_mask: u32,
    pub join_flags: u32,
    pub addr: *mut sockaddr,
}
#[test]
fn bindgen_test_layout_rdma_cm_join_mc_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_join_mc_attr_ex>(),
        16usize,
        concat!("Size of: ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_join_mc_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).join_flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(join_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(addr)
        )
    );
}
impl Default for rdma_cm_join_mc_attr_ex {
    fn default() -> Self {
        unsafe { ::std::mem::zeroed() }
    }
}
extern "C" {
    #[doc = " rdma_create_event_channel - Open a channel used to report communication events."]
    #[doc = " Description:"]
    #[doc = "   Asynchronous events are reported to users through event channels.  Each"]
    #[doc = "   event channel maps to a file descriptor."]
    #[doc = " Notes:"]
    #[doc = "   All created event channels must be destroyed by calling"]
    #[doc = "   rdma_destroy_event_channel.  Users should call rdma_get_cm_event to"]
    #[doc = "   retrieve events on an event channel."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event, rdma_destroy_event_channel"]
    pub fn rdma_create_event_channel() -> *mut rdma_event_channel;
}
extern "C" {
    #[doc = " rdma_destroy_event_channel - Close an event communication channel."]
    #[doc = " @channel: The communication channel to destroy."]
    #[doc = " Description:"]
    #[doc = "   Release all resources associated with an event channel and closes the"]
    #[doc = "   associated file descriptor."]
    #[doc = " Notes:"]
    #[doc = "   All rdma_cm_id's associated with the event channel must be destroyed,"]
    #[doc = "   and all returned events must be acked before calling this function."]
    #[doc = " See also:"]
    #[doc = "  rdma_create_event_channel, rdma_get_cm_event, rdma_ack_cm_event"]
    pub fn rdma_destroy_event_channel(channel: *mut rdma_event_channel);
}
extern "C" {
    #[doc = " rdma_create_id - Allocate a communication identifier."]
    #[doc = " @channel: The communication channel that events associated with the"]
    #[doc = "   allocated rdma_cm_id will be reported on."]
    #[doc = " @id: A reference where the allocated communication identifier will be"]
    #[doc = "   returned."]
    #[doc = " @context: User specified context associated with the rdma_cm_id."]
    #[doc = " @ps: RDMA port space."]
    #[doc = " Description:"]
    #[doc = "   Creates an identifier that is used to track communication information."]
    #[doc = " Notes:"]
    #[doc = "   Rdma_cm_id's are conceptually equivalent to a socket for RDMA"]
    #[doc = "   communication.  The difference is that RDMA communication requires"]
    #[doc = "   explicitly binding to a specified RDMA device before communication"]
    #[doc = "   can occur, and most operations are asynchronous in nature.  Communication"]
    #[doc = "   events on an rdma_cm_id are reported through the associated event"]
    #[doc = "   channel.  Users must release the rdma_cm_id by calling rdma_destroy_id."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_event_channel, rdma_destroy_id, rdma_get_devices,"]
    #[doc = "   rdma_bind_addr, rdma_resolve_addr, rdma_connect, rdma_listen,"]
    pub fn rdma_create_id(
        channel: *mut rdma_event_channel,
        id: *mut *mut rdma_cm_id,
        context: *mut ::std::os::raw::c_void,
        ps: rdma_port_space,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_create_ep - Allocate a communication identifier and qp."]
    #[doc = " @id: A reference where the allocated communication identifier will be"]
    #[doc = "   returned."]
    #[doc = " @res: Result from rdma_getaddrinfo, which specifies the source and"]
    #[doc = "   destination addresses, plus optional routing and connection information."]
    #[doc = " @pd: Optional protection domain.  This parameter is ignored if qp_init_attr"]
    #[doc = "   is NULL."]
    #[doc = " @qp_init_attr: Optional attributes for a QP created on the rdma_cm_id."]
    #[doc = " Description:"]
    #[doc = "   Create an identifier and option QP used for communication."]
    #[doc = " Notes:"]
    #[doc = "   If qp_init_attr is provided, then a queue pair will be allocated and"]
    #[doc = "   associated with the rdma_cm_id.  If a pd is provided, the QP will be"]
    #[doc = "   created on that PD.  Otherwise, the QP will be allocated on a default"]
    #[doc = "   PD."]
    #[doc = "   The rdma_cm_id will be set to use synchronous operations (connect,"]
    #[doc = "   listen, and get_request).  To convert to asynchronous operation, the"]
    #[doc = "   rdma_cm_id should be migrated to a user allocated event channel."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_create_qp, rdma_migrate_id, rdma_connect,"]
    #[doc = "   rdma_listen"]
    pub fn rdma_create_ep(
        id: *mut *mut rdma_cm_id,
        res: *mut rdma_addrinfo,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_destroy_ep - Deallocates a communication identifier and qp."]
    #[doc = " @id: The communication identifier to destroy."]
    #[doc = " Description:"]
    #[doc = "   Destroys the specified rdma_cm_id and any associated QP created"]
    #[doc = "   on that id."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_ep"]
    pub fn rdma_destroy_ep(id: *mut rdma_cm_id);
}
extern "C" {
    #[doc = " rdma_destroy_id - Release a communication identifier."]
    #[doc = " @id: The communication identifier to destroy."]
    #[doc = " Description:"]
    #[doc = "   Destroys the specified rdma_cm_id and cancels any outstanding"]
    #[doc = "   asynchronous operation."]
    #[doc = " Notes:"]
    #[doc = "   Users must free any associated QP with the rdma_cm_id before"]
    #[doc = "   calling this routine and ack an related events."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_destroy_qp, rdma_ack_cm_event"]
    pub fn rdma_destroy_id(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_bind_addr - Bind an RDMA identifier to a source address."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @addr: Local address information.  Wildcard values are permitted."]
    #[doc = " Description:"]
    #[doc = "   Associates a source address with an rdma_cm_id.  The address may be"]
    #[doc = "   wildcarded.  If binding to a specific local address, the rdma_cm_id"]
    #[doc = "   will also be bound to a local RDMA device."]
    #[doc = " Notes:"]
    #[doc = "   Typically, this routine is called before calling rdma_listen to bind"]
    #[doc = "   to a specific port number, but it may also be called on the active side"]
    #[doc = "   of a connection before calling rdma_resolve_addr to bind to a specific"]
    #[doc = "   address."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_listen, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_bind_addr(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_resolve_addr - Resolve destination and optional source addresses."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @src_addr: Source address information.  This parameter may be NULL."]
    #[doc = " @dst_addr: Destination address information."]
    #[doc = " @timeout_ms: Time to wait for resolution to complete."]
    #[doc = " Description:"]
    #[doc = "   Resolve destination and optional source addresses from IP addresses"]
    #[doc = "   to an RDMA address.  If successful, the specified rdma_cm_id will"]
    #[doc = "   be bound to a local device."]
    #[doc = " Notes:"]
    #[doc = "   This call is used to map a given destination IP address to a usable RDMA"]
    #[doc = "   address.  If a source address is given, the rdma_cm_id is bound to that"]
    #[doc = "   address, the same as if rdma_bind_addr were called.  If no source"]
    #[doc = "   address is given, and the rdma_cm_id has not yet been bound to a device,"]
    #[doc = "   then the rdma_cm_id will be bound to a source address based on the"]
    #[doc = "   local routing tables.  After this call, the rdma_cm_id will be bound to"]
    #[doc = "   an RDMA device.  This call is typically made from the active side of a"]
    #[doc = "   connection before calling rdma_resolve_route and rdma_connect."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_id, rdma_resolve_route, rdma_connect, rdma_create_qp,"]
    #[doc = "   rdma_get_cm_event, rdma_bind_addr"]
    pub fn rdma_resolve_addr(
        id: *mut rdma_cm_id,
        src_addr: *mut sockaddr,
        dst_addr: *mut sockaddr,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_resolve_route - Resolve the route information needed to establish a connection."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @timeout_ms: Time to wait for resolution to complete."]
    #[doc = " Description:"]
    #[doc = "   Resolves an RDMA route to the destination address in order to establish"]
    #[doc = "   a connection.  The destination address must have already been resolved"]
    #[doc = "   by calling rdma_resolve_addr."]
    #[doc = " Notes:"]
    #[doc = "   This is called on the client side of a connection after calling"]
    #[doc = "   rdma_resolve_addr, but before calling rdma_connect."]
    #[doc = " See also:"]
    #[doc = "   rdma_resolve_addr, rdma_connect, rdma_get_cm_event"]
    pub fn rdma_resolve_route(
        id: *mut rdma_cm_id,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_create_qp - Allocate a QP."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @pd: Optional protection domain for the QP."]
    #[doc = " @qp_init_attr: initial QP attributes."]
    #[doc = " Description:"]
    #[doc = "  Allocate a QP associated with the specified rdma_cm_id and transition it"]
    #[doc = "  for sending and receiving."]
    #[doc = " Notes:"]
    #[doc = "   The rdma_cm_id must be bound to a local RDMA device before calling this"]
    #[doc = "   function, and the protection domain must be for that same device."]
    #[doc = "   QPs allocated to an rdma_cm_id are automatically transitioned by the"]
    #[doc = "   librdmacm through their states.  After being allocated, the QP will be"]
    #[doc = "   ready to handle posting of receives.  If the QP is unconnected, it will"]
    #[doc = "   be ready to post sends."]
    #[doc = "   If pd is NULL, then the QP will be allocated using a default protection"]
    #[doc = "   domain associated with the underlying RDMA device."]
    #[doc = " See also:"]
    #[doc = "   rdma_bind_addr, rdma_resolve_addr, rdma_destroy_qp, ibv_create_qp,"]
    #[doc = "   ibv_modify_qp"]
    pub fn rdma_create_qp(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_qp_ex(
        id: *mut rdma_cm_id,
        qp_init_attr: *mut ibv_qp_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_destroy_qp - Deallocate a QP."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Destroy a QP allocated on the rdma_cm_id."]
    #[doc = " Notes:"]
    #[doc = "   Users must destroy any QP associated with an rdma_cm_id before"]
    #[doc = "   destroying the ID."]
    #[doc = " See also:"]
    #[doc = "   rdma_create_qp, rdma_destroy_id, ibv_destroy_qp"]
    pub fn rdma_destroy_qp(id: *mut rdma_cm_id);
}
extern "C" {
    #[doc = " rdma_connect - Initiate an active connection request."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @conn_param: optional connection parameters."]
    #[doc = " Description:"]
    #[doc = "   For a connected rdma_cm_id, this call initiates a connection request"]
    #[doc = "   to a remote destination.  For an unconnected rdma_cm_id, it initiates"]
    #[doc = "   a lookup of the remote QP providing the datagram service."]
    #[doc = " Notes:"]
    #[doc = "   Users must have resolved a route to the destination address"]
    #[doc = "   by having called rdma_resolve_route before calling this routine."]
    #[doc = "   A user may override the default connection parameters and exchange"]
    #[doc = "   private data as part of the connection by using the conn_param parameter."]
    #[doc = " See also:"]
    #[doc = "   rdma_resolve_route, rdma_disconnect, rdma_listen, rdma_get_cm_event"]
    pub fn rdma_connect(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_establish - Complete an active connection request."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Acknowledge an incoming connection response event and complete the"]
    #[doc = "   connection establishment."]
    #[doc = " Notes:"]
    #[doc = "   If a QP has not been created on the rdma_cm_id, this function should be"]
    #[doc = "   called by the active side to complete the connection, after getting connect"]
    #[doc = "   response event. This will trigger a connection established event on the"]
    #[doc = "   passive side."]
    #[doc = "   This function should not be used on an rdma_cm_id on which a QP has been"]
    #[doc = "   created."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_disconnect, rdma_get_cm_event"]
    pub fn rdma_establish(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_listen - Listen for incoming connection requests."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @backlog: backlog of incoming connection requests."]
    #[doc = " Description:"]
    #[doc = "   Initiates a listen for incoming connection requests or datagram service"]
    #[doc = "   lookup.  The listen will be restricted to the locally bound source"]
    #[doc = "   address."]
    #[doc = " Notes:"]
    #[doc = "   Users must have bound the rdma_cm_id to a local address by calling"]
    #[doc = "   rdma_bind_addr before calling this routine.  If the rdma_cm_id is"]
    #[doc = "   bound to a specific IP address, the listen will be restricted to that"]
    #[doc = "   address and the associated RDMA device.  If the rdma_cm_id is bound"]
    #[doc = "   to an RDMA port number only, the listen will occur across all RDMA"]
    #[doc = "   devices."]
    #[doc = " See also:"]
    #[doc = "   rdma_bind_addr, rdma_connect, rdma_accept, rdma_reject, rdma_get_cm_event"]
    pub fn rdma_listen(
        id: *mut rdma_cm_id,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_get_request"]
    pub fn rdma_get_request(
        listen: *mut rdma_cm_id,
        id: *mut *mut rdma_cm_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_accept - Called to accept a connection request."]
    #[doc = " @id: Connection identifier associated with the request."]
    #[doc = " @conn_param: Optional information needed to establish the connection."]
    #[doc = " Description:"]
    #[doc = "   Called from the listening side to accept a connection or datagram"]
    #[doc = "   service lookup request."]
    #[doc = " Notes:"]
    #[doc = "   Unlike the socket accept routine, rdma_accept is not called on a"]
    #[doc = "   listening rdma_cm_id.  Instead, after calling rdma_listen, the user"]
    #[doc = "   waits for a connection request event to occur.  Connection request"]
    #[doc = "   events give the user a newly created rdma_cm_id, similar to a new"]
    #[doc = "   socket, but the rdma_cm_id is bound to a specific RDMA device."]
    #[doc = "   rdma_accept is called on the new rdma_cm_id."]
    #[doc = "   A user may override the default connection parameters and exchange"]
    #[doc = "   private data as part of the connection by using the conn_param parameter."]
    #[doc = " See also:"]
    #[doc = "   rdma_listen, rdma_reject, rdma_get_cm_event"]
    pub fn rdma_accept(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_reject - Called to reject a connection request."]
    #[doc = " @id: Connection identifier associated with the request."]
    #[doc = " @private_data: Optional private data to send with the reject message."]
    #[doc = " @private_data_len: Size of the private_data to send, in bytes."]
    #[doc = " Description:"]
    #[doc = "   Called from the listening side to reject a connection or datagram"]
    #[doc = "   service lookup request."]
    #[doc = " Notes:"]
    #[doc = "   After receiving a connection request event, a user may call rdma_reject"]
    #[doc = "   to reject the request.  If the underlying RDMA transport supports"]
    #[doc = "   private data in the reject message, the specified data will be passed to"]
    #[doc = "   the remote side."]
    #[doc = " See also:"]
    #[doc = "   rdma_listen, rdma_accept, rdma_get_cm_event"]
    pub fn rdma_reject(
        id: *mut rdma_cm_id,
        private_data: *const ::std::os::raw::c_void,
        private_data_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_notify - Notifies the librdmacm of an asynchronous event."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " @event: Asynchronous event."]
    #[doc = " Description:"]
    #[doc = "   Used to notify the librdmacm of asynchronous events that have occurred"]
    #[doc = "   on a QP associated with the rdma_cm_id."]
    #[doc = " Notes:"]
    #[doc = "   Asynchronous events that occur on a QP are reported through the user's"]
    #[doc = "   device event handler.  This routine is used to notify the librdmacm of"]
    #[doc = "   communication events.  In most cases, use of this routine is not"]
    #[doc = "   necessary, however if connection establishment is done out of band"]
    #[doc = "   (such as done through Infiniband), it's possible to receive data on a"]
    #[doc = "   QP that is not yet considered connected.  This routine forces the"]
    #[doc = "   connection into an established state in this case in order to handle"]
    #[doc = "   the rare situation where the connection never forms on its own."]
    #[doc = "   Events that should be reported to the CM are: IB_EVENT_COMM_EST."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_accept, rdma_listen"]
    pub fn rdma_notify(id: *mut rdma_cm_id, event: ibv_event_type::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_disconnect - This function disconnects a connection."]
    #[doc = " @id: RDMA identifier."]
    #[doc = " Description:"]
    #[doc = "   Disconnects a connection and transitions any associated QP to the"]
    #[doc = "   error state."]
    #[doc = " See also:"]
    #[doc = "   rdma_connect, rdma_listen, rdma_accept"]
    pub fn rdma_disconnect(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_join_multicast - Joins a multicast group."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @addr: Multicast address identifying the group to join."]
    #[doc = " @context: User-defined context associated with the join request."]
    #[doc = " Description:"]
    #[doc = "   Joins a multicast group and attaches an associated QP to the group."]
    #[doc = " Notes:"]
    #[doc = "   Before joining a multicast group, the rdma_cm_id must be bound to"]
    #[doc = "   an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of"]
    #[doc = "   rdma_resolve_addr requires the local routing tables to resolve the"]
    #[doc = "   multicast address to an RDMA device.  The user must call"]
    #[doc = "   rdma_leave_multicast to leave the multicast group and release any"]
    #[doc = "   multicast resources.  The context is returned to the user through"]
    #[doc = "   the private_data field in the rdma_cm_event."]
    #[doc = " See also:"]
    #[doc = "   rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_join_multicast(
        id: *mut rdma_cm_id,
        addr: *mut sockaddr,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_leave_multicast - Leaves a multicast group."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @addr: Multicast address identifying the group to leave."]
    #[doc = " Description:"]
    #[doc = "   Leaves a multicast group and detaches an associated QP from the group."]
    #[doc = " Notes:"]
    #[doc = "   Calling this function before a group has been fully joined results in"]
    #[doc = "   canceling the join operation.  Users should be aware that messages"]
    #[doc = "   received from the multicast group may stilled be queued for"]
    #[doc = "   completion processing immediately after leaving a multicast group."]
    #[doc = "   Destroying an rdma_cm_id will automatically leave all multicast groups."]
    #[doc = " See also:"]
    #[doc = "   rdma_join_multicast, rdma_destroy_qp"]
    pub fn rdma_leave_multicast(id: *mut rdma_cm_id, addr: *mut sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_multicast_ex - Joins a multicast group with options."]
    #[doc = " @id: Communication identifier associated with the request."]
    #[doc = " @mc_join_attr: Extensive struct containing multicast join parameters."]
    #[doc = " @context: User-defined context associated with the join request."]
    #[doc = " Description:"]
    #[doc = "  Joins a multicast group with options. Currently supporting MC join flags."]
    #[doc = "  The QP will be attached based on the given join flag."]
    #[doc = "  Join message will be sent according to the join flag."]
    #[doc = " Notes:"]
    #[doc = "  Before joining a multicast group, the rdma_cm_id must be bound to"]
    #[doc = "  an RDMA device by calling rdma_bind_addr or rdma_resolve_addr.  Use of"]
    #[doc = "  rdma_resolve_addr requires the local routing tables to resolve the"]
    #[doc = "  multicast address to an RDMA device.  The user must call"]
    #[doc = "  rdma_leave_multicast to leave the multicast group and release any"]
    #[doc = "  multicast resources.  The context is returned to the user through"]
    #[doc = "  the private_data field in the rdma_cm_event."]
    #[doc = " See also:"]
    #[doc = "  rdma_leave_multicast, rdma_bind_addr, rdma_resolve_addr, rdma_create_qp"]
    pub fn rdma_join_multicast_ex(
        id: *mut rdma_cm_id,
        mc_join_attr: *mut rdma_cm_join_mc_attr_ex,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_get_cm_event - Retrieves the next pending communication event."]
    #[doc = " @channel: Event channel to check for events."]
    #[doc = " @event: Allocated information about the next communication event."]
    #[doc = " Description:"]
    #[doc = "   Retrieves a communication event.  If no events are pending, by default,"]
    #[doc = "   the call will block until an event is received."]
    #[doc = " Notes:"]
    #[doc = "   The default synchronous behavior of this routine can be changed by"]
    #[doc = "   modifying the file descriptor associated with the given channel.  All"]
    #[doc = "   events that are reported must be acknowledged by calling rdma_ack_cm_event."]
    #[doc = "   Destruction of an rdma_cm_id will block until related events have been"]
    #[doc = "   acknowledged."]
    #[doc = " See also:"]
    #[doc = "   rdma_ack_cm_event, rdma_create_event_channel, rdma_event_str"]
    pub fn rdma_get_cm_event(
        channel: *mut rdma_event_channel,
        event: *mut *mut rdma_cm_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_ack_cm_event - Free a communication event."]
    #[doc = " @event: Event to be released."]
    #[doc = " Description:"]
    #[doc = "   All events which are allocated by rdma_get_cm_event must be released,"]
    #[doc = "   there should be a one-to-one correspondence between successful gets"]
    #[doc = "   and acks."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event, rdma_destroy_id"]
    pub fn rdma_ack_cm_event(event: *mut rdma_cm_event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_src_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    pub fn rdma_get_dst_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    #[doc = " rdma_get_devices - Get list of RDMA devices currently available."]
    #[doc = " @num_devices: If non-NULL, set to the number of devices returned."]
    #[doc = " Description:"]
    #[doc = "   Return a NULL-terminated array of opened RDMA devices.  Callers can use"]
    #[doc = "   this routine to allocate resources on specific RDMA devices that will be"]
    #[doc = "   shared across multiple rdma_cm_id's."]
    #[doc = " Notes:"]
    #[doc = "   The returned array must be released by calling rdma_free_devices.  Devices"]
    #[doc = "   remain opened while the librdmacm is loaded."]
    #[doc = " See also:"]
    #[doc = "   rdma_free_devices"]
    pub fn rdma_get_devices(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_context;
}
extern "C" {
    #[doc = " rdma_free_devices - Frees the list of devices returned by rdma_get_devices."]
    #[doc = " @list: List of devices returned from rdma_get_devices."]
    #[doc = " Description:"]
    #[doc = "   Frees the device array returned by rdma_get_devices."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_devices"]
    pub fn rdma_free_devices(list: *mut *mut ibv_context);
}
extern "C" {
    #[doc = " rdma_event_str - Returns a string representation of an rdma cm event."]
    #[doc = " @event: Asynchronous event."]
    #[doc = " Description:"]
    #[doc = "   Returns a string representation of an asynchronous event."]
    #[doc = " See also:"]
    #[doc = "   rdma_get_cm_event"]
    pub fn rdma_event_str(event: rdma_cm_event_type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " rdma_set_option - Set options for an rdma_cm_id."]
    #[doc = " @id: Communication identifier to set option for."]
    #[doc = " @level: Protocol level of the option to set."]
    #[doc = " @optname: Name of the option to set."]
    #[doc = " @optval: Reference to the option data."]
    #[doc = " @optlen: The size of the %optval buffer."]
    pub fn rdma_set_option(
        id: *mut rdma_cm_id,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: size_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_migrate_id - Move an rdma_cm_id to a new event channel."]
    #[doc = " @id: Communication identifier to migrate."]
    #[doc = " @channel: New event channel for rdma_cm_id events."]
    pub fn rdma_migrate_id(
        id: *mut rdma_cm_id,
        channel: *mut rdma_event_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " rdma_getaddrinfo - RDMA address and route resolution service."]
    pub fn rdma_getaddrinfo(
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const rdma_addrinfo,
        res: *mut *mut rdma_addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_freeaddrinfo(res: *mut rdma_addrinfo);
}
extern "C" {
    #[doc = " rdma_init_qp_attr - Returns QP attributes."]
    #[doc = " @id: Communication identifier."]
    #[doc = " @qp_attr: A reference to a QP attributes struct containing"]
    #[doc = " response information."]
    #[doc = " @qp_attr_mask: A reference to a QP attributes mask containing"]
    #[doc = " response information."]
    pub fn rdma_init_qp_attr(
        id: *mut rdma_cm_id,
        qp_attr: *mut ibv_qp_attr,
        qp_attr_mask: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
