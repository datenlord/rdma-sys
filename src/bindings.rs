/* automatically generated by rust-bindgen 0.57.0 */

#[repr(C)]
pub struct __BindgenUnionField<T>(::std::marker::PhantomData<T>);
impl<T> __BindgenUnionField<T> {
    #[inline]
    pub const fn new() -> Self {
        __BindgenUnionField(::std::marker::PhantomData)
    }
    #[inline]
    pub unsafe fn as_ref(&self) -> &T {
        ::std::mem::transmute(self)
    }
    #[inline]
    pub unsafe fn as_mut(&mut self) -> &mut T {
        ::std::mem::transmute(self)
    }
}
impl<T> ::std::default::Default for __BindgenUnionField<T> {
    #[inline]
    fn default() -> Self {
        Self::new()
    }
}
impl<T> ::std::clone::Clone for __BindgenUnionField<T> {
    #[inline]
    fn clone(&self) -> Self {
        Self::new()
    }
}
impl<T> ::std::marker::Copy for __BindgenUnionField<T> {}
impl<T> ::std::fmt::Debug for __BindgenUnionField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__BindgenUnionField")
    }
}
impl<T> ::std::hash::Hash for __BindgenUnionField<T> {
    fn hash<H: ::std::hash::Hasher>(&self, _state: &mut H) {}
}
impl<T> ::std::cmp::PartialEq for __BindgenUnionField<T> {
    fn eq(&self, _other: &__BindgenUnionField<T>) -> bool {
        true
    }
}
impl<T> ::std::cmp::Eq for __BindgenUnionField<T> {}
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __time_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_internal_list {
    pub __prev: *mut __pthread_internal_list,
    pub __next: *mut __pthread_internal_list,
}
#[test]
fn bindgen_test_layout___pthread_internal_list() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_internal_list>(),
        16usize,
        concat!("Size of: ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_internal_list>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_internal_list))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__prev as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__prev)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_internal_list>())).__next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_internal_list),
            "::",
            stringify!(__next)
        )
    );
}
pub type __pthread_list_t = __pthread_internal_list;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_mutex_s {
    pub __lock: ::std::os::raw::c_int,
    pub __count: ::std::os::raw::c_uint,
    pub __owner: ::std::os::raw::c_int,
    pub __nusers: ::std::os::raw::c_uint,
    pub __kind: ::std::os::raw::c_int,
    pub __spins: ::std::os::raw::c_short,
    pub __elision: ::std::os::raw::c_short,
    pub __list: __pthread_list_t,
}
#[test]
fn bindgen_test_layout___pthread_mutex_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_mutex_s>(),
        40usize,
        concat!("Size of: ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_mutex_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_mutex_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__lock as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__lock)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__count as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__owner as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__owner)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__nusers as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__nusers)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__kind as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__kind)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__spins as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__spins)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__elision as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__elision)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_mutex_s>())).__list as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_mutex_s),
            "::",
            stringify!(__list)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s {
    pub __bindgen_anon_1: __pthread_cond_s__bindgen_ty_1,
    pub __bindgen_anon_2: __pthread_cond_s__bindgen_ty_2,
    pub __g_refs: [::std::os::raw::c_uint; 2usize],
    pub __g_size: [::std::os::raw::c_uint; 2usize],
    pub __g1_orig_size: ::std::os::raw::c_uint,
    pub __wrefs: ::std::os::raw::c_uint,
    pub __g_signals: [::std::os::raw::c_uint; 2usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1 {
    pub __wseq: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub __wseq32: __BindgenUnionField<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_1__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_1>())).__wseq32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_1),
            "::",
            stringify!(__wseq32)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2 {
    pub __g1_start: __BindgenUnionField<::std::os::raw::c_ulonglong>,
    pub __g1_start32: __BindgenUnionField<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>,
    pub bindgen_union_field: u64,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct __pthread_cond_s__bindgen_ty_2__bindgen_ty_1 {
    pub __low: ::std::os::raw::c_uint,
    pub __high: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__low
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__low)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2__bindgen_ty_1>())).__high
                as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(__high)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Size of: ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<__pthread_cond_s__bindgen_ty_2>())).__g1_start32 as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s__bindgen_ty_2),
            "::",
            stringify!(__g1_start32)
        )
    );
}
#[test]
fn bindgen_test_layout___pthread_cond_s() {
    assert_eq!(
        ::std::mem::size_of::<__pthread_cond_s>(),
        48usize,
        concat!("Size of: ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        ::std::mem::align_of::<__pthread_cond_s>(),
        8usize,
        concat!("Alignment of ", stringify!(__pthread_cond_s))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_refs as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_refs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_size as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g1_orig_size as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g1_orig_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__wrefs as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__wrefs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__pthread_cond_s>())).__g_signals as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(__pthread_cond_s),
            "::",
            stringify!(__g_signals)
        )
    );
}
pub type __u16 = ::std::os::raw::c_ushort;
pub type __u32 = ::std::os::raw::c_uint;
pub type __u64 = ::std::os::raw::c_ulonglong;
pub type __be16 = __u16;
pub type __be32 = __u32;
pub type __be64 = __u64;
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_LOCAL_WRITE: ib_uverbs_access_flags = ib_uverbs_access_flags(1);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_REMOTE_WRITE: ib_uverbs_access_flags = ib_uverbs_access_flags(2);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_REMOTE_READ: ib_uverbs_access_flags = ib_uverbs_access_flags(4);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_REMOTE_ATOMIC: ib_uverbs_access_flags = ib_uverbs_access_flags(8);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_MW_BIND: ib_uverbs_access_flags = ib_uverbs_access_flags(16);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_ZERO_BASED: ib_uverbs_access_flags = ib_uverbs_access_flags(32);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_ON_DEMAND: ib_uverbs_access_flags = ib_uverbs_access_flags(64);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_HUGETLB: ib_uverbs_access_flags = ib_uverbs_access_flags(128);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_RELAXED_ORDERING: ib_uverbs_access_flags =
        ib_uverbs_access_flags(1048576);
}
impl ib_uverbs_access_flags {
    pub const IB_UVERBS_ACCESS_OPTIONAL_RANGE: ib_uverbs_access_flags =
        ib_uverbs_access_flags(1072693248);
}
impl ::std::ops::BitOr<ib_uverbs_access_flags> for ib_uverbs_access_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ib_uverbs_access_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ib_uverbs_access_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ib_uverbs_access_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ib_uverbs_access_flags> for ib_uverbs_access_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ib_uverbs_access_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ib_uverbs_access_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ib_uverbs_access_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ib_uverbs_access_flags(pub ::std::os::raw::c_uint);
pub const IB_UVERBS_FLOW_ACTION_ESP_KEYMAT_AES_GCM: ib_uverbs_flow_action_esp_keymat = 0;
pub type ib_uverbs_flow_action_esp_keymat = ::std::os::raw::c_uint;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_NONE: ib_uverbs_flow_action_esp_replay = 0;
pub const IB_UVERBS_FLOW_ACTION_ESP_REPLAY_BMP: ib_uverbs_flow_action_esp_replay = 1;
pub type ib_uverbs_flow_action_esp_replay = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap {
    pub __bindgen_anon_1: ib_uverbs_flow_action_esp_encap__bindgen_ty_1,
    pub __bindgen_anon_2: ib_uverbs_flow_action_esp_encap__bindgen_ty_2,
    pub len: __u16,
    pub type_: __u16,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap__bindgen_ty_1 {
    pub val_ptr: __BindgenUnionField<*mut ::std::os::raw::c_void>,
    pub val_ptr_data_u64: __BindgenUnionField<__u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>())).val_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_1>()))
                .val_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_1),
            "::",
            stringify!(val_ptr_data_u64)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp_encap__bindgen_ty_2 {
    pub next_ptr: __BindgenUnionField<*mut ib_uverbs_flow_action_esp_encap>,
    pub next_ptr_data_u64: __BindgenUnionField<__u64>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>())).next_ptr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap__bindgen_ty_2>()))
                .next_ptr_data_u64 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap__bindgen_ty_2),
            "::",
            stringify!(next_ptr_data_u64)
        )
    );
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp_encap() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp_encap>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp_encap>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp_encap))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).len as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp_encap>())).type_ as *const _ as usize
        },
        18usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp_encap),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ib_uverbs_flow_action_esp {
    pub spi: __u32,
    pub seq: __u32,
    pub tfc_pad: __u32,
    pub flags: __u32,
    pub hard_limit_pkts: __u64,
}
#[test]
fn bindgen_test_layout_ib_uverbs_flow_action_esp() {
    assert_eq!(
        ::std::mem::size_of::<ib_uverbs_flow_action_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ib_uverbs_flow_action_esp>(),
        8usize,
        concat!("Alignment of ", stringify!(ib_uverbs_flow_action_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(seq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).tfc_pad as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(tfc_pad)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ib_uverbs_flow_action_esp>())).hard_limit_pkts as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ib_uverbs_flow_action_esp),
            "::",
            stringify!(hard_limit_pkts)
        )
    );
}
pub mod ib_uverbs_advise_mr_advice {
    pub type Type = ::std::os::raw::c_uint;
    pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH: Type = 0;
    pub const IB_UVERBS_ADVISE_MR_ADVICE_PREFETCH_WRITE: Type = 1;
}
pub mod rdma_driver_id {
    pub type Type = ::std::os::raw::c_uint;
    pub const RDMA_DRIVER_UNKNOWN: Type = 0;
    pub const RDMA_DRIVER_MLX5: Type = 1;
    pub const RDMA_DRIVER_MLX4: Type = 2;
    pub const RDMA_DRIVER_CXGB3: Type = 3;
    pub const RDMA_DRIVER_CXGB4: Type = 4;
    pub const RDMA_DRIVER_MTHCA: Type = 5;
    pub const RDMA_DRIVER_BNXT_RE: Type = 6;
    pub const RDMA_DRIVER_OCRDMA: Type = 7;
    pub const RDMA_DRIVER_NES: Type = 8;
    pub const RDMA_DRIVER_I40IW: Type = 9;
    pub const RDMA_DRIVER_VMW_PVRDMA: Type = 10;
    pub const RDMA_DRIVER_QEDR: Type = 11;
    pub const RDMA_DRIVER_HNS: Type = 12;
    pub const RDMA_DRIVER_USNIC: Type = 13;
    pub const RDMA_DRIVER_RXE: Type = 14;
    pub const RDMA_DRIVER_HFI1: Type = 15;
    pub const RDMA_DRIVER_QIB: Type = 16;
    pub const RDMA_DRIVER_EFA: Type = 17;
    pub const RDMA_DRIVER_SIW: Type = 18;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_gid__bindgen_ty_1 {
    pub subnet_prefix: __be64,
    pub interface_id: __be64,
}
#[test]
fn bindgen_test_layout_ibv_gid__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_gid__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_gid__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_gid__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).subnet_prefix as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(subnet_prefix)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_gid__bindgen_ty_1>())).interface_id as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_gid__bindgen_ty_1),
            "::",
            stringify!(interface_id)
        )
    );
}
pub mod ibv_node_type {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_NODE_UNKNOWN: Type = -1;
    pub const IBV_NODE_CA: Type = 1;
    pub const IBV_NODE_SWITCH: Type = 2;
    pub const IBV_NODE_ROUTER: Type = 3;
    pub const IBV_NODE_RNIC: Type = 4;
    pub const IBV_NODE_USNIC: Type = 5;
    pub const IBV_NODE_USNIC_UDP: Type = 6;
    pub const IBV_NODE_UNSPECIFIED: Type = 7;
}
pub mod ibv_transport_type {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_TRANSPORT_UNKNOWN: Type = -1;
    pub const IBV_TRANSPORT_IB: Type = 0;
    pub const IBV_TRANSPORT_IWARP: Type = 1;
    pub const IBV_TRANSPORT_USNIC: Type = 2;
    pub const IBV_TRANSPORT_USNIC_UDP: Type = 3;
    pub const IBV_TRANSPORT_UNSPECIFIED: Type = 4;
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RESIZE_MAX_WR: ibv_device_cap_flags = ibv_device_cap_flags(1);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_BAD_PKEY_CNTR: ibv_device_cap_flags = ibv_device_cap_flags(2);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_BAD_QKEY_CNTR: ibv_device_cap_flags = ibv_device_cap_flags(4);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RAW_MULTI: ibv_device_cap_flags = ibv_device_cap_flags(8);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_AUTO_PATH_MIG: ibv_device_cap_flags = ibv_device_cap_flags(16);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_CHANGE_PHY_PORT: ibv_device_cap_flags = ibv_device_cap_flags(32);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_UD_AV_PORT_ENFORCE: ibv_device_cap_flags = ibv_device_cap_flags(64);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_CURR_QP_STATE_MOD: ibv_device_cap_flags = ibv_device_cap_flags(128);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SHUTDOWN_PORT: ibv_device_cap_flags = ibv_device_cap_flags(256);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_INIT_TYPE: ibv_device_cap_flags = ibv_device_cap_flags(512);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_PORT_ACTIVE_EVENT: ibv_device_cap_flags = ibv_device_cap_flags(1024);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SYS_IMAGE_GUID: ibv_device_cap_flags = ibv_device_cap_flags(2048);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RC_RNR_NAK_GEN: ibv_device_cap_flags = ibv_device_cap_flags(4096);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_SRQ_RESIZE: ibv_device_cap_flags = ibv_device_cap_flags(8192);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_N_NOTIFY_CQ: ibv_device_cap_flags = ibv_device_cap_flags(16384);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW: ibv_device_cap_flags = ibv_device_cap_flags(131072);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_UD_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(262144);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_XRC: ibv_device_cap_flags = ibv_device_cap_flags(1048576);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_MGT_EXTENSIONS: ibv_device_cap_flags = ibv_device_cap_flags(2097152);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW_TYPE_2A: ibv_device_cap_flags = ibv_device_cap_flags(8388608);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MEM_WINDOW_TYPE_2B: ibv_device_cap_flags = ibv_device_cap_flags(16777216);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RC_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(33554432);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_RAW_IP_CSUM: ibv_device_cap_flags = ibv_device_cap_flags(67108864);
}
impl ibv_device_cap_flags {
    pub const IBV_DEVICE_MANAGED_FLOW_STEERING: ibv_device_cap_flags =
        ibv_device_cap_flags(536870912);
}
impl ::std::ops::BitOr<ibv_device_cap_flags> for ibv_device_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_device_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_device_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_device_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_device_cap_flags> for ibv_device_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_device_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_device_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_device_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_device_cap_flags(pub ::std::os::raw::c_uint);
pub mod ibv_atomic_cap {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_ATOMIC_NONE: Type = 0;
    pub const IBV_ATOMIC_HCA: Type = 1;
    pub const IBV_ATOMIC_GLOB: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_alloc_dm_attr {
    pub length: usize,
    pub log_align_req: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_alloc_dm_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_alloc_dm_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_alloc_dm_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_alloc_dm_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).length as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).log_align_req as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(log_align_req)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_alloc_dm_attr>())).comp_mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_alloc_dm_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_dm {
    pub context: *mut ibv_context,
    pub memcpy_to_dm: ::std::option::Option<
        unsafe extern "C" fn(
            dm: *mut ibv_dm,
            dm_offset: u64,
            host_addr: *const ::std::os::raw::c_void,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub memcpy_from_dm: ::std::option::Option<
        unsafe extern "C" fn(
            host_addr: *mut ::std::os::raw::c_void,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_dm() {
    assert_eq!(
        ::std::mem::size_of::<ibv_dm>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_dm))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_dm>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_dm))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_to_dm as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_to_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).memcpy_from_dm as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(memcpy_from_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_dm>())).comp_mask as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_dm),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr {
    pub fw_ver: [::std::os::raw::c_char; 64usize],
    pub node_guid: __be64,
    pub sys_image_guid: __be64,
    pub max_mr_size: u64,
    pub page_size_cap: u64,
    pub vendor_id: u32,
    pub vendor_part_id: u32,
    pub hw_ver: u32,
    pub max_qp: ::std::os::raw::c_int,
    pub max_qp_wr: ::std::os::raw::c_int,
    pub device_cap_flags: ::std::os::raw::c_uint,
    pub max_sge: ::std::os::raw::c_int,
    pub max_sge_rd: ::std::os::raw::c_int,
    pub max_cq: ::std::os::raw::c_int,
    pub max_cqe: ::std::os::raw::c_int,
    pub max_mr: ::std::os::raw::c_int,
    pub max_pd: ::std::os::raw::c_int,
    pub max_qp_rd_atom: ::std::os::raw::c_int,
    pub max_ee_rd_atom: ::std::os::raw::c_int,
    pub max_res_rd_atom: ::std::os::raw::c_int,
    pub max_qp_init_rd_atom: ::std::os::raw::c_int,
    pub max_ee_init_rd_atom: ::std::os::raw::c_int,
    pub atomic_cap: ibv_atomic_cap::Type,
    pub max_ee: ::std::os::raw::c_int,
    pub max_rdd: ::std::os::raw::c_int,
    pub max_mw: ::std::os::raw::c_int,
    pub max_raw_ipv6_qp: ::std::os::raw::c_int,
    pub max_raw_ethy_qp: ::std::os::raw::c_int,
    pub max_mcast_grp: ::std::os::raw::c_int,
    pub max_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_total_mcast_qp_attach: ::std::os::raw::c_int,
    pub max_ah: ::std::os::raw::c_int,
    pub max_fmr: ::std::os::raw::c_int,
    pub max_map_per_fmr: ::std::os::raw::c_int,
    pub max_srq: ::std::os::raw::c_int,
    pub max_srq_wr: ::std::os::raw::c_int,
    pub max_srq_sge: ::std::os::raw::c_int,
    pub max_pkeys: u16,
    pub local_ca_ack_delay: u8,
    pub phys_port_cnt: u8,
}
#[test]
fn bindgen_test_layout_ibv_device_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr>(),
        232usize,
        concat!("Size of: ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).fw_ver as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(fw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).node_guid as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(node_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).sys_image_guid as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(sys_image_guid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr_size as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).page_size_cap as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(page_size_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_id as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).vendor_part_id as *const _ as usize },
        100usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(vendor_part_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).hw_ver as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(hw_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp as *const _ as usize },
        108usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_wr as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_wr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).device_cap_flags as *const _ as usize
        },
        116usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(device_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_sge_rd as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_sge_rd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cq as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_cqe as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mr as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pd as *const _ as usize },
        140usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_rd_atom as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_rd_atom as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_res_rd_atom as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_res_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_qp_init_rd_atom as *const _ as usize
        },
        156usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_qp_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_ee_init_rd_atom as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee_init_rd_atom)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).atomic_cap as *const _ as usize },
        164usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(atomic_cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ee as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ee)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_rdd as *const _ as usize },
        172usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_rdd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mw as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ipv6_qp as *const _ as usize },
        180usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ipv6_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_raw_ethy_qp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_raw_ethy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_grp as *const _ as usize },
        188usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_grp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_mcast_qp_attach as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).max_total_mcast_qp_attach as *const _
                as usize
        },
        196usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_total_mcast_qp_attach)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_ah as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_ah)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_fmr as *const _ as usize },
        204usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_map_per_fmr as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_map_per_fmr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq as *const _ as usize },
        212usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_wr as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_srq_sge as *const _ as usize },
        220usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_srq_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).max_pkeys as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(max_pkeys)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr>())).local_ca_ack_delay as *const _ as usize
        },
        226usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(local_ca_ack_delay)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr>())).phys_port_cnt as *const _ as usize },
        227usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr),
            "::",
            stringify!(phys_port_cnt)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_query_device_ex_input {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_query_device_ex_input() {
    assert_eq!(
        ::std::mem::size_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_query_device_ex_input>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_query_device_ex_input))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_query_device_ex_input>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_query_device_ex_input),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_SEND: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(1);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_RECV: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(2);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_WRITE: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(4);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_READ: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(8);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_ATOMIC: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(16);
}
impl ibv_odp_transport_cap_bits {
    pub const IBV_ODP_SUPPORT_SRQ_RECV: ibv_odp_transport_cap_bits = ibv_odp_transport_cap_bits(32);
}
impl ::std::ops::BitOr<ibv_odp_transport_cap_bits> for ibv_odp_transport_cap_bits {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_odp_transport_cap_bits(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_odp_transport_cap_bits {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_odp_transport_cap_bits) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_odp_transport_cap_bits> for ibv_odp_transport_cap_bits {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_odp_transport_cap_bits(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_odp_transport_cap_bits {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_odp_transport_cap_bits) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_odp_transport_cap_bits(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_odp_caps {
    pub general_caps: u64,
    pub per_transport_caps: ibv_odp_caps__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_odp_caps__bindgen_ty_1 {
    pub rc_odp_caps: u32,
    pub uc_odp_caps: u32,
    pub ud_odp_caps: u32,
}
#[test]
fn bindgen_test_layout_ibv_odp_caps__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps__bindgen_ty_1>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).rc_odp_caps as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(rc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).uc_odp_caps as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(uc_odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_odp_caps__bindgen_ty_1>())).ud_odp_caps as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps__bindgen_ty_1),
            "::",
            stringify!(ud_odp_caps)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_odp_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_odp_caps>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_odp_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_odp_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).general_caps as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(general_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_odp_caps>())).per_transport_caps as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_odp_caps),
            "::",
            stringify!(per_transport_caps)
        )
    );
}
impl ibv_odp_general_caps {
    pub const IBV_ODP_SUPPORT: ibv_odp_general_caps = ibv_odp_general_caps(1);
}
impl ibv_odp_general_caps {
    pub const IBV_ODP_SUPPORT_IMPLICIT: ibv_odp_general_caps = ibv_odp_general_caps(2);
}
impl ::std::ops::BitOr<ibv_odp_general_caps> for ibv_odp_general_caps {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_odp_general_caps(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_odp_general_caps {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_odp_general_caps) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_odp_general_caps> for ibv_odp_general_caps {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_odp_general_caps(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_odp_general_caps {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_odp_general_caps) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_odp_general_caps(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tso_caps {
    pub max_tso: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_tso_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tso_caps>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tso_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tso_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).max_tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(max_tso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tso_caps>())).supported_qpts as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tso_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
impl ibv_rx_hash_function_flags {
    pub const IBV_RX_HASH_FUNC_TOEPLITZ: ibv_rx_hash_function_flags = ibv_rx_hash_function_flags(1);
}
impl ::std::ops::BitOr<ibv_rx_hash_function_flags> for ibv_rx_hash_function_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rx_hash_function_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rx_hash_function_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rx_hash_function_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rx_hash_function_flags> for ibv_rx_hash_function_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rx_hash_function_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rx_hash_function_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rx_hash_function_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rx_hash_function_flags(pub ::std::os::raw::c_uint);
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_IPV4: ibv_rx_hash_fields = ibv_rx_hash_fields(1);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_IPV4: ibv_rx_hash_fields = ibv_rx_hash_fields(2);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_IPV6: ibv_rx_hash_fields = ibv_rx_hash_fields(4);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_IPV6: ibv_rx_hash_fields = ibv_rx_hash_fields(8);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_PORT_TCP: ibv_rx_hash_fields = ibv_rx_hash_fields(16);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_PORT_TCP: ibv_rx_hash_fields = ibv_rx_hash_fields(32);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_SRC_PORT_UDP: ibv_rx_hash_fields = ibv_rx_hash_fields(64);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_DST_PORT_UDP: ibv_rx_hash_fields = ibv_rx_hash_fields(128);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_IPSEC_SPI: ibv_rx_hash_fields = ibv_rx_hash_fields(256);
}
impl ibv_rx_hash_fields {
    pub const IBV_RX_HASH_INNER: ibv_rx_hash_fields = ibv_rx_hash_fields(2147483648);
}
impl ::std::ops::BitOr<ibv_rx_hash_fields> for ibv_rx_hash_fields {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rx_hash_fields(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rx_hash_fields {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rx_hash_fields) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rx_hash_fields> for ibv_rx_hash_fields {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rx_hash_fields(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rx_hash_fields {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rx_hash_fields) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rx_hash_fields(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rss_caps {
    pub supported_qpts: u32,
    pub max_rwq_indirection_tables: u32,
    pub max_rwq_indirection_table_size: u32,
    pub rx_hash_fields_mask: u64,
    pub rx_hash_function: u8,
}
#[test]
fn bindgen_test_layout_ibv_rss_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rss_caps>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rss_caps>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rss_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).supported_qpts as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_tables as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_tables)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).max_rwq_indirection_table_size as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(max_rwq_indirection_table_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rss_caps>())).rx_hash_function as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rss_caps),
            "::",
            stringify!(rx_hash_function)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_packet_pacing_caps {
    pub qp_rate_limit_min: u32,
    pub qp_rate_limit_max: u32,
    pub supported_qpts: u32,
}
#[test]
fn bindgen_test_layout_ibv_packet_pacing_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_packet_pacing_caps>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_packet_pacing_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_packet_pacing_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_min as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_min)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).qp_rate_limit_max as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(qp_rate_limit_max)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_packet_pacing_caps>())).supported_qpts as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_packet_pacing_caps),
            "::",
            stringify!(supported_qpts)
        )
    );
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_CVLAN_STRIPPING: ibv_raw_packet_caps = ibv_raw_packet_caps(1);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_SCATTER_FCS: ibv_raw_packet_caps = ibv_raw_packet_caps(2);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_IP_CSUM: ibv_raw_packet_caps = ibv_raw_packet_caps(4);
}
impl ibv_raw_packet_caps {
    pub const IBV_RAW_PACKET_CAP_DELAY_DROP: ibv_raw_packet_caps = ibv_raw_packet_caps(8);
}
impl ::std::ops::BitOr<ibv_raw_packet_caps> for ibv_raw_packet_caps {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_raw_packet_caps(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_raw_packet_caps {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_raw_packet_caps) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_raw_packet_caps> for ibv_raw_packet_caps {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_raw_packet_caps(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_raw_packet_caps {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_raw_packet_caps) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_raw_packet_caps(pub ::std::os::raw::c_uint);
impl ibv_tm_cap_flags {
    pub const IBV_TM_CAP_RC: ibv_tm_cap_flags = ibv_tm_cap_flags(1);
}
impl ::std::ops::BitOr<ibv_tm_cap_flags> for ibv_tm_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_tm_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_tm_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_tm_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_tm_cap_flags> for ibv_tm_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_tm_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_tm_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_tm_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_tm_cap_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tm_caps {
    pub max_rndv_hdr_size: u32,
    pub max_num_tags: u32,
    pub flags: u32,
    pub max_ops: u32,
    pub max_sge: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_caps>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_caps>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_rndv_hdr_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_rndv_hdr_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_num_tags as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_ops as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_caps>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_caps),
            "::",
            stringify!(max_sge)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_moderation_caps {
    pub max_cq_count: u16,
    pub max_cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_cq_moderation_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_moderation_caps>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_moderation_caps>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_cq_moderation_caps))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_count)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_moderation_caps>())).max_cq_period as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_moderation_caps),
            "::",
            stringify!(max_cq_period)
        )
    );
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_4_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(1);
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_8_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(2);
}
impl ibv_pci_atomic_op_size {
    pub const IBV_PCI_ATOMIC_OPERATION_16_BYTE_SIZE_SUP: ibv_pci_atomic_op_size =
        ibv_pci_atomic_op_size(4);
}
impl ::std::ops::BitOr<ibv_pci_atomic_op_size> for ibv_pci_atomic_op_size {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_pci_atomic_op_size(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_pci_atomic_op_size {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_pci_atomic_op_size) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_pci_atomic_op_size> for ibv_pci_atomic_op_size {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_pci_atomic_op_size(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_pci_atomic_op_size {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_pci_atomic_op_size) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_pci_atomic_op_size(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pci_atomic_caps {
    pub fetch_add: u16,
    pub swap: u16,
    pub compare_swap: u16,
}
#[test]
fn bindgen_test_layout_ibv_pci_atomic_caps() {
    assert_eq!(
        ::std::mem::size_of::<ibv_pci_atomic_caps>(),
        6usize,
        concat!("Size of: ", stringify!(ibv_pci_atomic_caps))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_pci_atomic_caps>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_pci_atomic_caps))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).fetch_add as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(fetch_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).swap as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_pci_atomic_caps>())).compare_swap as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pci_atomic_caps),
            "::",
            stringify!(compare_swap)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device_attr_ex {
    pub orig_attr: ibv_device_attr,
    pub comp_mask: u32,
    pub odp_caps: ibv_odp_caps,
    pub completion_timestamp_mask: u64,
    pub hca_core_clock: u64,
    pub device_cap_flags_ex: u64,
    pub tso_caps: ibv_tso_caps,
    pub rss_caps: ibv_rss_caps,
    pub max_wq_type_rq: u32,
    pub packet_pacing_caps: ibv_packet_pacing_caps,
    pub raw_packet_caps: u32,
    pub tm_caps: ibv_tm_caps,
    pub cq_mod_caps: ibv_cq_moderation_caps,
    pub max_dm_size: u64,
    pub pci_atomic_caps: ibv_pci_atomic_caps,
    pub xrc_odp_caps: u32,
}
#[test]
fn bindgen_test_layout_ibv_device_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device_attr_ex>(),
        400usize,
        concat!("Size of: ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).orig_attr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(orig_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).comp_mask as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).odp_caps as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(odp_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).completion_timestamp_mask as *const _
                as usize
        },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(completion_timestamp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).hca_core_clock as *const _ as usize
        },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(hca_core_clock)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).device_cap_flags_ex as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(device_cap_flags_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tso_caps as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tso_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).rss_caps as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(rss_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_wq_type_rq as *const _ as usize
        },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_wq_type_rq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).packet_pacing_caps as *const _ as usize
        },
        332usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(packet_pacing_caps)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).raw_packet_caps as *const _ as usize
        },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(raw_packet_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).tm_caps as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(tm_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).cq_mod_caps as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(cq_mod_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).max_dm_size as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(max_dm_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_device_attr_ex>())).pci_atomic_caps as *const _ as usize
        },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(pci_atomic_caps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device_attr_ex>())).xrc_odp_caps as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device_attr_ex),
            "::",
            stringify!(xrc_odp_caps)
        )
    );
}
pub mod ibv_mtu {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MTU_256: Type = 1;
    pub const IBV_MTU_512: Type = 2;
    pub const IBV_MTU_1024: Type = 3;
    pub const IBV_MTU_2048: Type = 4;
    pub const IBV_MTU_4096: Type = 5;
}
pub mod ibv_port_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_PORT_NOP: Type = 0;
    pub const IBV_PORT_DOWN: Type = 1;
    pub const IBV_PORT_INIT: Type = 2;
    pub const IBV_PORT_ARMED: Type = 3;
    pub const IBV_PORT_ACTIVE: Type = 4;
    pub const IBV_PORT_ACTIVE_DEFER: Type = 5;
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SM: ibv_port_cap_flags = ibv_port_cap_flags(2);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_OPT_IPD_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_AUTO_MIGR_SUP: ibv_port_cap_flags = ibv_port_cap_flags(32);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SL_MAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(64);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_MKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(128);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_NVRAM: ibv_port_cap_flags = ibv_port_cap_flags(256);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LED_INFO_SUP: ibv_port_cap_flags = ibv_port_cap_flags(512);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SYS_IMAGE_GUID_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2048);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_PKEY_SW_EXT_PORT_TRAP_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4096);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_EXTENDED_SPEEDS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16384);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CAP_MASK2_SUP: ibv_port_cap_flags = ibv_port_cap_flags(32768);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CM_SUP: ibv_port_cap_flags = ibv_port_cap_flags(65536);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_SNMP_TUNNEL_SUP: ibv_port_cap_flags = ibv_port_cap_flags(131072);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_REINIT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(262144);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DEVICE_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(524288);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_VENDOR_CLASS_SUP: ibv_port_cap_flags = ibv_port_cap_flags(1048576);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_DR_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(2097152);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CAP_MASK_NOTICE_SUP: ibv_port_cap_flags = ibv_port_cap_flags(4194304);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_BOOT_MGMT_SUP: ibv_port_cap_flags = ibv_port_cap_flags(8388608);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_LINK_LATENCY_SUP: ibv_port_cap_flags = ibv_port_cap_flags(16777216);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_CLIENT_REG_SUP: ibv_port_cap_flags = ibv_port_cap_flags(33554432);
}
impl ibv_port_cap_flags {
    pub const IBV_PORT_IP_BASED_GIDS: ibv_port_cap_flags = ibv_port_cap_flags(67108864);
}
impl ::std::ops::BitOr<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_port_cap_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_port_cap_flags> for ibv_port_cap_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_port_cap_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_port_cap_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_port_cap_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_port_cap_flags(pub ::std::os::raw::c_uint);
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_SET_NODE_DESC_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(1);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_INFO_EXT_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(2);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_VIRT_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(4);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_SWITCH_PORT_STATE_TABLE_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(8);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_LINK_WIDTH_2X_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(16);
}
impl ibv_port_cap_flags2 {
    pub const IBV_PORT_LINK_SPEED_HDR_SUP: ibv_port_cap_flags2 = ibv_port_cap_flags2(32);
}
impl ::std::ops::BitOr<ibv_port_cap_flags2> for ibv_port_cap_flags2 {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_port_cap_flags2(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_port_cap_flags2 {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_port_cap_flags2) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_port_cap_flags2> for ibv_port_cap_flags2 {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_port_cap_flags2(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_port_cap_flags2 {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_port_cap_flags2) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_port_cap_flags2(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_port_attr {
    pub state: ibv_port_state::Type,
    pub max_mtu: ibv_mtu::Type,
    pub active_mtu: ibv_mtu::Type,
    pub gid_tbl_len: ::std::os::raw::c_int,
    pub port_cap_flags: u32,
    pub max_msg_sz: u32,
    pub bad_pkey_cntr: u32,
    pub qkey_viol_cntr: u32,
    pub pkey_tbl_len: u16,
    pub lid: u16,
    pub sm_lid: u16,
    pub lmc: u8,
    pub max_vl_num: u8,
    pub sm_sl: u8,
    pub subnet_timeout: u8,
    pub init_type_reply: u8,
    pub active_width: u8,
    pub active_speed: u8,
    pub phys_state: u8,
    pub link_layer: u8,
    pub flags: u8,
    pub port_cap_flags2: u16,
}
#[test]
fn bindgen_test_layout_ibv_port_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_port_attr>(),
        52usize,
        concat!("Size of: ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_port_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_port_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_mtu as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).gid_tbl_len as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(gid_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).port_cap_flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(port_cap_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_msg_sz as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_msg_sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).bad_pkey_cntr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(bad_pkey_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).qkey_viol_cntr as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(qkey_viol_cntr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).pkey_tbl_len as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(pkey_tbl_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_lid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_lid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).lmc as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(lmc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).max_vl_num as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(max_vl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).sm_sl as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(sm_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).subnet_timeout as *const _ as usize },
        41usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(subnet_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).init_type_reply as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(init_type_reply)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_width as *const _ as usize },
        43usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).active_speed as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(active_speed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).phys_state as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(phys_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).link_layer as *const _ as usize },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(link_layer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).flags as *const _ as usize },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_port_attr>())).port_cap_flags2 as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_port_attr),
            "::",
            stringify!(port_cap_flags2)
        )
    );
}
pub mod ibv_event_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_EVENT_CQ_ERR: Type = 0;
    pub const IBV_EVENT_QP_FATAL: Type = 1;
    pub const IBV_EVENT_QP_REQ_ERR: Type = 2;
    pub const IBV_EVENT_QP_ACCESS_ERR: Type = 3;
    pub const IBV_EVENT_COMM_EST: Type = 4;
    pub const IBV_EVENT_SQ_DRAINED: Type = 5;
    pub const IBV_EVENT_PATH_MIG: Type = 6;
    pub const IBV_EVENT_PATH_MIG_ERR: Type = 7;
    pub const IBV_EVENT_DEVICE_FATAL: Type = 8;
    pub const IBV_EVENT_PORT_ACTIVE: Type = 9;
    pub const IBV_EVENT_PORT_ERR: Type = 10;
    pub const IBV_EVENT_LID_CHANGE: Type = 11;
    pub const IBV_EVENT_PKEY_CHANGE: Type = 12;
    pub const IBV_EVENT_SM_CHANGE: Type = 13;
    pub const IBV_EVENT_SRQ_ERR: Type = 14;
    pub const IBV_EVENT_SRQ_LIMIT_REACHED: Type = 15;
    pub const IBV_EVENT_QP_LAST_WQE_REACHED: Type = 16;
    pub const IBV_EVENT_CLIENT_REREGISTER: Type = 17;
    pub const IBV_EVENT_GID_CHANGE: Type = 18;
    pub const IBV_EVENT_WQ_FATAL: Type = 19;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_async_event__bindgen_ty_1 {
    pub cq: __BindgenUnionField<*mut ibv_cq>,
    pub qp: __BindgenUnionField<*mut ibv_qp>,
    pub srq: __BindgenUnionField<*mut ibv_srq>,
    pub wq: __BindgenUnionField<*mut ibv_wq>,
    pub port_num: __BindgenUnionField<::std::os::raw::c_int>,
    pub bindgen_union_field: u64,
}
#[test]
fn bindgen_test_layout_ibv_async_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_async_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_async_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).cq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).qp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).srq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).wq as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(wq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_async_event__bindgen_ty_1>())).port_num as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_async_event__bindgen_ty_1),
            "::",
            stringify!(port_num)
        )
    );
}
pub mod ibv_wc_status {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WC_SUCCESS: Type = 0;
    pub const IBV_WC_LOC_LEN_ERR: Type = 1;
    pub const IBV_WC_LOC_QP_OP_ERR: Type = 2;
    pub const IBV_WC_LOC_EEC_OP_ERR: Type = 3;
    pub const IBV_WC_LOC_PROT_ERR: Type = 4;
    pub const IBV_WC_WR_FLUSH_ERR: Type = 5;
    pub const IBV_WC_MW_BIND_ERR: Type = 6;
    pub const IBV_WC_BAD_RESP_ERR: Type = 7;
    pub const IBV_WC_LOC_ACCESS_ERR: Type = 8;
    pub const IBV_WC_REM_INV_REQ_ERR: Type = 9;
    pub const IBV_WC_REM_ACCESS_ERR: Type = 10;
    pub const IBV_WC_REM_OP_ERR: Type = 11;
    pub const IBV_WC_RETRY_EXC_ERR: Type = 12;
    pub const IBV_WC_RNR_RETRY_EXC_ERR: Type = 13;
    pub const IBV_WC_LOC_RDD_VIOL_ERR: Type = 14;
    pub const IBV_WC_REM_INV_RD_REQ_ERR: Type = 15;
    pub const IBV_WC_REM_ABORT_ERR: Type = 16;
    pub const IBV_WC_INV_EECN_ERR: Type = 17;
    pub const IBV_WC_INV_EEC_STATE_ERR: Type = 18;
    pub const IBV_WC_FATAL_ERR: Type = 19;
    pub const IBV_WC_RESP_TIMEOUT_ERR: Type = 20;
    pub const IBV_WC_GENERAL_ERR: Type = 21;
    pub const IBV_WC_TM_ERR: Type = 22;
    pub const IBV_WC_TM_RNDV_INCOMPLETE: Type = 23;
}
extern "C" {
    pub fn ibv_wc_status_str(status: ibv_wc_status::Type) -> *const ::std::os::raw::c_char;
}
pub mod ibv_wc_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WC_SEND: Type = 0;
    pub const IBV_WC_RDMA_WRITE: Type = 1;
    pub const IBV_WC_RDMA_READ: Type = 2;
    pub const IBV_WC_COMP_SWAP: Type = 3;
    pub const IBV_WC_FETCH_ADD: Type = 4;
    pub const IBV_WC_BIND_MW: Type = 5;
    pub const IBV_WC_LOCAL_INV: Type = 6;
    pub const IBV_WC_TSO: Type = 7;
    pub const IBV_WC_RECV: Type = 128;
    pub const IBV_WC_RECV_RDMA_WITH_IMM: Type = 129;
    pub const IBV_WC_TM_ADD: Type = 130;
    pub const IBV_WC_TM_DEL: Type = 131;
    pub const IBV_WC_TM_SYNC: Type = 132;
    pub const IBV_WC_TM_RECV: Type = 133;
    pub const IBV_WC_TM_NO_TAG: Type = 134;
    pub const IBV_WC_DRIVER1: Type = 135;
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_BYTE_LEN: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(1);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_IMM: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(2);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_QP_NUM: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(4);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SRC_QP: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(8);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SLID: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(16);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_SL: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(32);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_DLID_PATH_BITS: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(64);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP: ibv_create_cq_wc_flags =
        ibv_create_cq_wc_flags(128);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_CVLAN: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(256);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_FLOW_TAG: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(512);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_TM_INFO: ibv_create_cq_wc_flags = ibv_create_cq_wc_flags(1024);
}
impl ibv_create_cq_wc_flags {
    pub const IBV_WC_EX_WITH_COMPLETION_TIMESTAMP_WALLCLOCK: ibv_create_cq_wc_flags =
        ibv_create_cq_wc_flags(2048);
}
impl ::std::ops::BitOr<ibv_create_cq_wc_flags> for ibv_create_cq_wc_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_create_cq_wc_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_create_cq_wc_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_create_cq_wc_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_create_cq_wc_flags> for ibv_create_cq_wc_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_create_cq_wc_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_create_cq_wc_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_create_cq_wc_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_create_cq_wc_flags(pub ::std::os::raw::c_uint);
impl ibv_wc_flags {
    pub const IBV_WC_GRH: ibv_wc_flags = ibv_wc_flags(1);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_IMM: ibv_wc_flags = ibv_wc_flags(2);
}
impl ibv_wc_flags {
    pub const IBV_WC_IP_CSUM_OK: ibv_wc_flags = ibv_wc_flags(4);
}
impl ibv_wc_flags {
    pub const IBV_WC_WITH_INV: ibv_wc_flags = ibv_wc_flags(8);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_SYNC_REQ: ibv_wc_flags = ibv_wc_flags(16);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_MATCH: ibv_wc_flags = ibv_wc_flags(32);
}
impl ibv_wc_flags {
    pub const IBV_WC_TM_DATA_VALID: ibv_wc_flags = ibv_wc_flags(64);
}
impl ::std::ops::BitOr<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wc_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wc_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wc_flags> for ibv_wc_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wc_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wc_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wc_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wc_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc__bindgen_ty_1 {
    pub imm_data: __BindgenUnionField<__be32>,
    pub invalidated_rkey: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wc__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).imm_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_wc__bindgen_ty_1>())).invalidated_rkey as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc__bindgen_ty_1),
            "::",
            stringify!(invalidated_rkey)
        )
    );
}
impl ibv_access_flags {
    pub const IBV_ACCESS_LOCAL_WRITE: ibv_access_flags = ibv_access_flags(1);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_WRITE: ibv_access_flags = ibv_access_flags(2);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_READ: ibv_access_flags = ibv_access_flags(4);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_REMOTE_ATOMIC: ibv_access_flags = ibv_access_flags(8);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_MW_BIND: ibv_access_flags = ibv_access_flags(16);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ZERO_BASED: ibv_access_flags = ibv_access_flags(32);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_ON_DEMAND: ibv_access_flags = ibv_access_flags(64);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_HUGETLB: ibv_access_flags = ibv_access_flags(128);
}
impl ibv_access_flags {
    pub const IBV_ACCESS_RELAXED_ORDERING: ibv_access_flags = ibv_access_flags(1048576);
}
impl ::std::ops::BitOr<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_access_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_access_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_access_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_access_flags> for ibv_access_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_access_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_access_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_access_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_access_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_pd {
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_pd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_pd>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_pd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_pd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_pd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_pd>())).handle as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_pd),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_td_init_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_td_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_td_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_td {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_td() {
    assert_eq!(
        ::std::mem::size_of::<ibv_td>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_td))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_td>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_td))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_td>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_td),
            "::",
            stringify!(context)
        )
    );
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_FD: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(1);
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_OFLAGS: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(2);
}
impl ibv_xrcd_init_attr_mask {
    pub const IBV_XRCD_INIT_ATTR_RESERVED: ibv_xrcd_init_attr_mask = ibv_xrcd_init_attr_mask(4);
}
impl ::std::ops::BitOr<ibv_xrcd_init_attr_mask> for ibv_xrcd_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_xrcd_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_xrcd_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_xrcd_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_xrcd_init_attr_mask> for ibv_xrcd_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_xrcd_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_xrcd_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_xrcd_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_xrcd_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_xrcd_init_attr {
    pub comp_mask: u32,
    pub fd: ::std::os::raw::c_int,
    pub oflags: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_xrcd_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd_init_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_xrcd_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).fd as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd_init_attr>())).oflags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd_init_attr),
            "::",
            stringify!(oflags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_xrcd {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_xrcd() {
    assert_eq!(
        ::std::mem::size_of::<ibv_xrcd>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_xrcd>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_xrcd))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_xrcd>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_xrcd),
            "::",
            stringify!(context)
        )
    );
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_TRANSLATION: ibv_rereg_mr_flags = ibv_rereg_mr_flags(1);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_PD: ibv_rereg_mr_flags = ibv_rereg_mr_flags(2);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_CHANGE_ACCESS: ibv_rereg_mr_flags = ibv_rereg_mr_flags(4);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_KEEP_VALID: ibv_rereg_mr_flags = ibv_rereg_mr_flags(8);
}
impl ibv_rereg_mr_flags {
    pub const IBV_REREG_MR_FLAGS_SUPPORTED: ibv_rereg_mr_flags = ibv_rereg_mr_flags(15);
}
impl ::std::ops::BitOr<ibv_rereg_mr_flags> for ibv_rereg_mr_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_rereg_mr_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_rereg_mr_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_rereg_mr_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_rereg_mr_flags> for ibv_rereg_mr_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_rereg_mr_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_rereg_mr_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_rereg_mr_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_rereg_mr_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mr {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
    pub handle: u32,
    pub lkey: u32,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_mr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).addr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).length as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).handle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).lkey as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(lkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mr>())).rkey as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mr),
            "::",
            stringify!(rkey)
        )
    );
}
pub mod ibv_mw_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MW_TYPE_1: Type = 1;
    pub const IBV_MW_TYPE_2: Type = 2;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_mw {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub rkey: u32,
    pub handle: u32,
    pub type_: ibv_mw_type::Type,
}
#[test]
fn bindgen_test_layout_ibv_mw() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_mw))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).rkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).handle as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw>())).type_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
pub struct ibv_grh {
    pub version_tclass_flow: __be32,
    pub paylen: __be16,
    pub next_hdr: u8,
    pub hop_limit: u8,
    pub sgid: ibv_gid,
    pub dgid: ibv_gid,
}
#[test]
fn bindgen_test_layout_ibv_grh() {
    assert_eq!(
        ::std::mem::size_of::<ibv_grh>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_grh))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_grh>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_grh))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).version_tclass_flow as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(version_tclass_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).paylen as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(paylen)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).next_hdr as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).hop_limit as *const _ as usize },
        7usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).sgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_grh>())).dgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_grh),
            "::",
            stringify!(dgid)
        )
    );
}
pub mod ibv_rate {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_RATE_MAX: Type = 0;
    pub const IBV_RATE_2_5_GBPS: Type = 2;
    pub const IBV_RATE_5_GBPS: Type = 5;
    pub const IBV_RATE_10_GBPS: Type = 3;
    pub const IBV_RATE_20_GBPS: Type = 6;
    pub const IBV_RATE_30_GBPS: Type = 4;
    pub const IBV_RATE_40_GBPS: Type = 7;
    pub const IBV_RATE_60_GBPS: Type = 8;
    pub const IBV_RATE_80_GBPS: Type = 9;
    pub const IBV_RATE_120_GBPS: Type = 10;
    pub const IBV_RATE_14_GBPS: Type = 11;
    pub const IBV_RATE_56_GBPS: Type = 12;
    pub const IBV_RATE_112_GBPS: Type = 13;
    pub const IBV_RATE_168_GBPS: Type = 14;
    pub const IBV_RATE_25_GBPS: Type = 15;
    pub const IBV_RATE_100_GBPS: Type = 16;
    pub const IBV_RATE_200_GBPS: Type = 17;
    pub const IBV_RATE_300_GBPS: Type = 18;
    pub const IBV_RATE_28_GBPS: Type = 19;
    pub const IBV_RATE_50_GBPS: Type = 20;
    pub const IBV_RATE_400_GBPS: Type = 21;
    pub const IBV_RATE_600_GBPS: Type = 22;
}
extern "C" {
    pub fn ibv_rate_to_mult(rate: ibv_rate::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_rate_to_mbps(rate: ibv_rate::Type) -> ::std::os::raw::c_int;
}
impl ibv_srq_attr_mask {
    pub const IBV_SRQ_MAX_WR: ibv_srq_attr_mask = ibv_srq_attr_mask(1);
}
impl ibv_srq_attr_mask {
    pub const IBV_SRQ_LIMIT: ibv_srq_attr_mask = ibv_srq_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_srq_attr_mask> for ibv_srq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_srq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_srq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_srq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_srq_attr_mask> for ibv_srq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_srq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_srq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_srq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_srq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq_attr {
    pub max_wr: u32,
    pub max_sge: u32,
    pub srq_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_srq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).max_sge as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_attr>())).srq_limit as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_attr),
            "::",
            stringify!(srq_limit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq_init_attr {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).srq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr),
            "::",
            stringify!(attr)
        )
    );
}
pub mod ibv_srq_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_SRQT_BASIC: Type = 0;
    pub const IBV_SRQT_XRC: Type = 1;
    pub const IBV_SRQT_TM: Type = 2;
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_TYPE: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(1);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_PD: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(2);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_XRCD: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(4);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_CQ: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(8);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_TM: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(16);
}
impl ibv_srq_init_attr_mask {
    pub const IBV_SRQ_INIT_ATTR_RESERVED: ibv_srq_init_attr_mask = ibv_srq_init_attr_mask(32);
}
impl ::std::ops::BitOr<ibv_srq_init_attr_mask> for ibv_srq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_srq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_srq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_srq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_srq_init_attr_mask> for ibv_srq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_srq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_srq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_srq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_srq_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_tm_cap {
    pub max_num_tags: u32,
    pub max_ops: u32,
}
#[test]
fn bindgen_test_layout_ibv_tm_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_tm_cap>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_tm_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_tm_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_num_tags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_num_tags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_tm_cap>())).max_ops as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_tm_cap),
            "::",
            stringify!(max_ops)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_srq_init_attr_ex {
    pub srq_context: *mut ::std::os::raw::c_void,
    pub attr: ibv_srq_attr,
    pub comp_mask: u32,
    pub srq_type: ibv_srq_type::Type,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub cq: *mut ibv_cq,
    pub tm_cap: ibv_tm_cap,
}
#[test]
fn bindgen_test_layout_ibv_srq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq_init_attr_ex>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq_init_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_context as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).attr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).comp_mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).srq_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(srq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).pd as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).xrcd as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).cq as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq_init_attr_ex>())).tm_cap as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq_init_attr_ex),
            "::",
            stringify!(tm_cap)
        )
    );
}
pub mod ibv_wq_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WQT_RQ: Type = 0;
}
impl ibv_wq_init_attr_mask {
    pub const IBV_WQ_INIT_ATTR_FLAGS: ibv_wq_init_attr_mask = ibv_wq_init_attr_mask(1);
}
impl ibv_wq_init_attr_mask {
    pub const IBV_WQ_INIT_ATTR_RESERVED: ibv_wq_init_attr_mask = ibv_wq_init_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_wq_init_attr_mask> for ibv_wq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_init_attr_mask> for ibv_wq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_CVLAN_STRIPPING: ibv_wq_flags = ibv_wq_flags(1);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_SCATTER_FCS: ibv_wq_flags = ibv_wq_flags(2);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_DELAY_DROP: ibv_wq_flags = ibv_wq_flags(4);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_PCI_WRITE_END_PADDING: ibv_wq_flags = ibv_wq_flags(8);
}
impl ibv_wq_flags {
    pub const IBV_WQ_FLAGS_RESERVED: ibv_wq_flags = ibv_wq_flags(16);
}
impl ::std::ops::BitOr<ibv_wq_flags> for ibv_wq_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_flags> for ibv_wq_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq_init_attr {
    pub wq_context: *mut ::std::os::raw::c_void,
    pub wq_type: ibv_wq_type::Type,
    pub max_wr: u32,
    pub max_sge: u32,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub comp_mask: u32,
    pub create_flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_init_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).wq_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_wr as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).max_sge as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(max_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).pd as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_init_attr>())).create_flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_init_attr),
            "::",
            stringify!(create_flags)
        )
    );
}
pub mod ibv_wq_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WQS_RESET: Type = 0;
    pub const IBV_WQS_RDY: Type = 1;
    pub const IBV_WQS_ERR: Type = 2;
    pub const IBV_WQS_UNKNOWN: Type = 3;
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_STATE: ibv_wq_attr_mask = ibv_wq_attr_mask(1);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_CURR_STATE: ibv_wq_attr_mask = ibv_wq_attr_mask(2);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_FLAGS: ibv_wq_attr_mask = ibv_wq_attr_mask(4);
}
impl ibv_wq_attr_mask {
    pub const IBV_WQ_ATTR_RESERVED: ibv_wq_attr_mask = ibv_wq_attr_mask(8);
}
impl ::std::ops::BitOr<ibv_wq_attr_mask> for ibv_wq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_wq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_wq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_wq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_wq_attr_mask> for ibv_wq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_wq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_wq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_wq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_wq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wq_attr {
    pub attr_mask: u32,
    pub wq_state: ibv_wq_state::Type,
    pub curr_wq_state: ibv_wq_state::Type,
    pub flags: u32,
    pub flags_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_wq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).wq_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).curr_wq_state as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(curr_wq_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq_attr>())).flags_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq_attr),
            "::",
            stringify!(flags_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rwq_ind_table {
    pub context: *mut ibv_context,
    pub ind_tbl_handle: ::std::os::raw::c_int,
    pub ind_tbl_num: ::std::os::raw::c_int,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_handle as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).ind_tbl_num as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(ind_tbl_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rwq_ind_table>())).comp_mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl ibv_ind_table_init_attr_mask {
    pub const IBV_CREATE_IND_TABLE_RESERVED: ibv_ind_table_init_attr_mask =
        ibv_ind_table_init_attr_mask(1);
}
impl ::std::ops::BitOr<ibv_ind_table_init_attr_mask> for ibv_ind_table_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_ind_table_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_ind_table_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_ind_table_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_ind_table_init_attr_mask> for ibv_ind_table_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_ind_table_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_ind_table_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_ind_table_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_ind_table_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rwq_ind_table_init_attr {
    pub log_ind_tbl_size: u32,
    pub ind_tbl: *mut *mut ibv_wq,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_rwq_ind_table_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rwq_ind_table_init_attr>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rwq_ind_table_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rwq_ind_table_init_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).log_ind_tbl_size as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(log_ind_tbl_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).ind_tbl as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rwq_ind_table_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rwq_ind_table_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
pub mod ibv_qp_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_QPT_RC: Type = 2;
    pub const IBV_QPT_UC: Type = 3;
    pub const IBV_QPT_UD: Type = 4;
    pub const IBV_QPT_RAW_PACKET: Type = 8;
    pub const IBV_QPT_XRC_SEND: Type = 9;
    pub const IBV_QPT_XRC_RECV: Type = 10;
    pub const IBV_QPT_DRIVER: Type = 255;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_cap {
    pub max_send_wr: u32,
    pub max_recv_wr: u32,
    pub max_send_sge: u32,
    pub max_recv_sge: u32,
    pub max_inline_data: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_cap() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_cap>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_cap>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_cap))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_wr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_wr as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_wr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_send_sge as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_send_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_recv_sge as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_recv_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_cap>())).max_inline_data as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_cap),
            "::",
            stringify!(max_inline_data)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_init_attr {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr),
            "::",
            stringify!(sq_sig_all)
        )
    );
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_PD: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(1);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_XRCD: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(2);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_CREATE_FLAGS: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(4);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_MAX_TSO_HEADER: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(8);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_IND_TABLE: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(16);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_RX_HASH: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(32);
}
impl ibv_qp_init_attr_mask {
    pub const IBV_QP_INIT_ATTR_SEND_OPS_FLAGS: ibv_qp_init_attr_mask = ibv_qp_init_attr_mask(64);
}
impl ::std::ops::BitOr<ibv_qp_init_attr_mask> for ibv_qp_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_init_attr_mask> for ibv_qp_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_BLOCK_SELF_MCAST_LB: ibv_qp_create_flags = ibv_qp_create_flags(2);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_SCATTER_FCS: ibv_qp_create_flags = ibv_qp_create_flags(256);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_CVLAN_STRIPPING: ibv_qp_create_flags = ibv_qp_create_flags(512);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_SOURCE_QPN: ibv_qp_create_flags = ibv_qp_create_flags(1024);
}
impl ibv_qp_create_flags {
    pub const IBV_QP_CREATE_PCI_WRITE_END_PADDING: ibv_qp_create_flags = ibv_qp_create_flags(2048);
}
impl ::std::ops::BitOr<ibv_qp_create_flags> for ibv_qp_create_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_create_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_create_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_create_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_create_flags> for ibv_qp_create_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_create_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_create_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_create_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_create_flags(pub ::std::os::raw::c_uint);
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_WRITE: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(1);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_WRITE_WITH_IMM: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(2);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND: ibv_qp_create_send_ops_flags = ibv_qp_create_send_ops_flags(4);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND_WITH_IMM: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(8);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_RDMA_READ: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(16);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_ATOMIC_CMP_AND_SWP: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(32);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_ATOMIC_FETCH_AND_ADD: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(64);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_LOCAL_INV: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(128);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_BIND_MW: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(256);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_SEND_WITH_INV: ibv_qp_create_send_ops_flags =
        ibv_qp_create_send_ops_flags(512);
}
impl ibv_qp_create_send_ops_flags {
    pub const IBV_QP_EX_WITH_TSO: ibv_qp_create_send_ops_flags = ibv_qp_create_send_ops_flags(1024);
}
impl ::std::ops::BitOr<ibv_qp_create_send_ops_flags> for ibv_qp_create_send_ops_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_create_send_ops_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_create_send_ops_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_create_send_ops_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_create_send_ops_flags> for ibv_qp_create_send_ops_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_create_send_ops_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_create_send_ops_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_create_send_ops_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_create_send_ops_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_rx_hash_conf {
    pub rx_hash_function: u8,
    pub rx_hash_key_len: u8,
    pub rx_hash_key: *mut u8,
    pub rx_hash_fields_mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_rx_hash_conf() {
    assert_eq!(
        ::std::mem::size_of::<ibv_rx_hash_conf>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_rx_hash_conf>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_rx_hash_conf))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_function as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_function)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key_len as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_key as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_key)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_rx_hash_conf>())).rx_hash_fields_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_rx_hash_conf),
            "::",
            stringify!(rx_hash_fields_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_init_attr_ex {
    pub qp_context: *mut ::std::os::raw::c_void,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub cap: ibv_qp_cap,
    pub qp_type: ibv_qp_type::Type,
    pub sq_sig_all: ::std::os::raw::c_int,
    pub comp_mask: u32,
    pub pd: *mut ibv_pd,
    pub xrcd: *mut ibv_xrcd,
    pub create_flags: u32,
    pub max_tso_header: u16,
    pub rwq_ind_tbl: *mut ibv_rwq_ind_table,
    pub rx_hash_conf: ibv_rx_hash_conf,
    pub source_qpn: u32,
    pub send_ops_flags: u64,
}
#[test]
fn bindgen_test_layout_ibv_qp_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_init_attr_ex>(),
        136usize,
        concat!("Size of: ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).send_cq as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).recv_cq as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).srq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).cap as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).qp_type as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).sq_sig_all as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(sq_sig_all)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).comp_mask as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).pd as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).xrcd as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).create_flags as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(create_flags)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).max_tso_header as *const _ as usize
        },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(max_tso_header)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rwq_ind_tbl as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rwq_ind_tbl)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).rx_hash_conf as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(rx_hash_conf)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).source_qpn as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(source_qpn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_init_attr_ex>())).send_ops_flags as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_init_attr_ex),
            "::",
            stringify!(send_ops_flags)
        )
    );
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_NUM: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(1);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_XRCD: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(2);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_CONTEXT: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(4);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_TYPE: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(8);
}
impl ibv_qp_open_attr_mask {
    pub const IBV_QP_OPEN_ATTR_RESERVED: ibv_qp_open_attr_mask = ibv_qp_open_attr_mask(16);
}
impl ::std::ops::BitOr<ibv_qp_open_attr_mask> for ibv_qp_open_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_open_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_open_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_open_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_open_attr_mask> for ibv_qp_open_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_open_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_open_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_open_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_open_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_open_attr {
    pub comp_mask: u32,
    pub qp_num: u32,
    pub xrcd: *mut ibv_xrcd,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_ibv_qp_open_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_open_attr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_open_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_open_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_num as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).xrcd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_open_attr>())).qp_type as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_open_attr),
            "::",
            stringify!(qp_type)
        )
    );
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(1);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CUR_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(2);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_EN_SQD_ASYNC_NOTIFY: ibv_qp_attr_mask = ibv_qp_attr_mask(4);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ACCESS_FLAGS: ibv_qp_attr_mask = ibv_qp_attr_mask(8);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PKEY_INDEX: ibv_qp_attr_mask = ibv_qp_attr_mask(16);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PORT: ibv_qp_attr_mask = ibv_qp_attr_mask(32);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_QKEY: ibv_qp_attr_mask = ibv_qp_attr_mask(64);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_AV: ibv_qp_attr_mask = ibv_qp_attr_mask(128);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MTU: ibv_qp_attr_mask = ibv_qp_attr_mask(256);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_TIMEOUT: ibv_qp_attr_mask = ibv_qp_attr_mask(512);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RETRY_CNT: ibv_qp_attr_mask = ibv_qp_attr_mask(1024);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RNR_RETRY: ibv_qp_attr_mask = ibv_qp_attr_mask(2048);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(4096);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_QP_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(8192);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_ALT_PATH: ibv_qp_attr_mask = ibv_qp_attr_mask(16384);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MIN_RNR_TIMER: ibv_qp_attr_mask = ibv_qp_attr_mask(32768);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_SQ_PSN: ibv_qp_attr_mask = ibv_qp_attr_mask(65536);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_MAX_DEST_RD_ATOMIC: ibv_qp_attr_mask = ibv_qp_attr_mask(131072);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_PATH_MIG_STATE: ibv_qp_attr_mask = ibv_qp_attr_mask(262144);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_CAP: ibv_qp_attr_mask = ibv_qp_attr_mask(524288);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_DEST_QPN: ibv_qp_attr_mask = ibv_qp_attr_mask(1048576);
}
impl ibv_qp_attr_mask {
    pub const IBV_QP_RATE_LIMIT: ibv_qp_attr_mask = ibv_qp_attr_mask(33554432);
}
impl ::std::ops::BitOr<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_qp_attr_mask> for ibv_qp_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_qp_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_qp_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_qp_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_qp_attr_mask(pub ::std::os::raw::c_uint);
pub mod ibv_qp_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_QPS_RESET: Type = 0;
    pub const IBV_QPS_INIT: Type = 1;
    pub const IBV_QPS_RTR: Type = 2;
    pub const IBV_QPS_RTS: Type = 3;
    pub const IBV_QPS_SQD: Type = 4;
    pub const IBV_QPS_SQE: Type = 5;
    pub const IBV_QPS_ERR: Type = 6;
    pub const IBV_QPS_UNKNOWN: Type = 7;
}
pub mod ibv_mig_state {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_MIG_MIGRATED: Type = 0;
    pub const IBV_MIG_REARM: Type = 1;
    pub const IBV_MIG_ARMED: Type = 2;
}
#[repr(C)]
pub struct ibv_qp_attr {
    pub qp_state: ibv_qp_state::Type,
    pub cur_qp_state: ibv_qp_state::Type,
    pub path_mtu: ibv_mtu::Type,
    pub path_mig_state: ibv_mig_state::Type,
    pub qkey: u32,
    pub rq_psn: u32,
    pub sq_psn: u32,
    pub dest_qp_num: u32,
    pub qp_access_flags: ::std::os::raw::c_uint,
    pub cap: ibv_qp_cap,
    pub ah_attr: ibv_ah_attr,
    pub alt_ah_attr: ibv_ah_attr,
    pub pkey_index: u16,
    pub alt_pkey_index: u16,
    pub en_sqd_async_notify: u8,
    pub sq_draining: u8,
    pub max_rd_atomic: u8,
    pub max_dest_rd_atomic: u8,
    pub min_rnr_timer: u8,
    pub port_num: u8,
    pub timeout: u8,
    pub retry_cnt: u8,
    pub rnr_retry: u8,
    pub alt_port_num: u8,
    pub alt_timeout: u8,
    pub rate_limit: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_attr>(),
        144usize,
        concat!("Size of: ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_state as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cur_qp_state as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cur_qp_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mtu as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).path_mig_state as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(path_mig_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qkey as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rq_psn as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_psn as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_psn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).dest_qp_num as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(dest_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).qp_access_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(qp_access_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).cap as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(cap)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).ah_attr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_ah_attr as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_ah_attr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).pkey_index as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_pkey_index as *const _ as usize },
        122usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_pkey_index)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).en_sqd_async_notify as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(en_sqd_async_notify)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).sq_draining as *const _ as usize },
        125usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(sq_draining)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_rd_atomic as *const _ as usize },
        126usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).max_dest_rd_atomic as *const _ as usize },
        127usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(max_dest_rd_atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).min_rnr_timer as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(min_rnr_timer)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).port_num as *const _ as usize },
        129usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).timeout as *const _ as usize },
        130usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).retry_cnt as *const _ as usize },
        131usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(retry_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rnr_retry as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rnr_retry)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_port_num as *const _ as usize },
        133usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).alt_timeout as *const _ as usize },
        134usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(alt_timeout)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_attr>())).rate_limit as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_attr),
            "::",
            stringify!(rate_limit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_qp_rate_limit_attr {
    pub rate_limit: u32,
    pub max_burst_sz: u32,
    pub typical_pkt_sz: u16,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp_rate_limit_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_rate_limit_attr>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_rate_limit_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_qp_rate_limit_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).rate_limit as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(rate_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).max_burst_sz as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(max_burst_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).typical_pkt_sz as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(typical_pkt_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_rate_limit_attr>())).comp_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_rate_limit_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
pub mod ibv_wr_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WR_RDMA_WRITE: Type = 0;
    pub const IBV_WR_RDMA_WRITE_WITH_IMM: Type = 1;
    pub const IBV_WR_SEND: Type = 2;
    pub const IBV_WR_SEND_WITH_IMM: Type = 3;
    pub const IBV_WR_RDMA_READ: Type = 4;
    pub const IBV_WR_ATOMIC_CMP_AND_SWP: Type = 5;
    pub const IBV_WR_ATOMIC_FETCH_AND_ADD: Type = 6;
    pub const IBV_WR_LOCAL_INV: Type = 7;
    pub const IBV_WR_BIND_MW: Type = 8;
    pub const IBV_WR_SEND_WITH_INV: Type = 9;
    pub const IBV_WR_TSO: Type = 10;
    pub const IBV_WR_DRIVER1: Type = 11;
}
impl ibv_send_flags {
    pub const IBV_SEND_FENCE: ibv_send_flags = ibv_send_flags(1);
}
impl ibv_send_flags {
    pub const IBV_SEND_SIGNALED: ibv_send_flags = ibv_send_flags(2);
}
impl ibv_send_flags {
    pub const IBV_SEND_SOLICITED: ibv_send_flags = ibv_send_flags(4);
}
impl ibv_send_flags {
    pub const IBV_SEND_INLINE: ibv_send_flags = ibv_send_flags(8);
}
impl ibv_send_flags {
    pub const IBV_SEND_IP_CSUM: ibv_send_flags = ibv_send_flags(16);
}
impl ::std::ops::BitOr<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_send_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_send_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_send_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_send_flags> for ibv_send_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_send_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_send_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_send_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_send_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_data_buf {
    pub addr: *mut ::std::os::raw::c_void,
    pub length: usize,
}
#[test]
fn bindgen_test_layout_ibv_data_buf() {
    assert_eq!(
        ::std::mem::size_of::<ibv_data_buf>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_data_buf))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_data_buf>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_data_buf))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_data_buf>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_data_buf),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_data_buf>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_data_buf),
            "::",
            stringify!(length)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_sge {
    pub addr: u64,
    pub length: u32,
    pub lkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_sge() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sge>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_sge))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sge>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sge))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).length as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(length)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sge>())).lkey as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sge),
            "::",
            stringify!(lkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_1 {
    pub imm_data: __BindgenUnionField<__be32>,
    pub invalidate_rkey: __BindgenUnionField<u32>,
    pub bindgen_union_field: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).imm_data as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(imm_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_1>())).invalidate_rkey as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_1),
            "::",
            stringify!(invalidate_rkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2 {
    pub rdma: __BindgenUnionField<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>,
    pub atomic: __BindgenUnionField<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>,
    pub ud: __BindgenUnionField<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>,
    pub bindgen_union_field: [u64; 4usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_1 {
    pub remote_addr: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_2 {
    pub remote_addr: u64,
    pub compare_add: u64,
    pub swap: u64,
    pub rkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        32usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).remote_addr
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(remote_addr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).compare_add
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(compare_add)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).swap as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(swap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_2>())).rkey as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_2),
            "::",
            stringify!(rkey)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_2__bindgen_ty_3 {
    pub ah: *mut ibv_ah,
    pub remote_qpn: u32,
    pub remote_qkey: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).ah as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qpn
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qpn)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2__bindgen_ty_3>())).remote_qkey
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2__bindgen_ty_3),
            "::",
            stringify!(remote_qkey)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_2>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).rdma as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(rdma)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).atomic as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(atomic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_2>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_2),
            "::",
            stringify!(ud)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3 {
    pub xrc: __BindgenUnionField<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>,
    pub bindgen_union_field: u32,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_3__bindgen_ty_1 {
    pub remote_srqn: u32,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3__bindgen_ty_1>())).remote_srqn
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3__bindgen_ty_1),
            "::",
            stringify!(remote_srqn)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_3>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_3>())).xrc as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_3),
            "::",
            stringify!(xrc)
        )
    );
}
#[repr(C)]
pub struct ibv_send_wr__bindgen_ty_4 {
    pub bind_mw: __BindgenUnionField<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>,
    pub tso: __BindgenUnionField<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>,
    pub bindgen_union_field: [u64; 6usize],
}
#[repr(C)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_1 {
    pub mw: *mut ibv_mw,
    pub rkey: u32,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        48usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).mw as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(mw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).rkey as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(rkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_1>())).bind_info
                as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_1),
            "::",
            stringify!(bind_info)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_send_wr__bindgen_ty_4__bindgen_ty_2 {
    pub hdr: *mut ::std::os::raw::c_void,
    pub hdr_sz: u16,
    pub mss: u16,
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).hdr_sz as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(hdr_sz)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4__bindgen_ty_2>())).mss as *const _
                as usize
        },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4__bindgen_ty_2),
            "::",
            stringify!(mss)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_send_wr__bindgen_ty_4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_send_wr__bindgen_ty_4>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_send_wr__bindgen_ty_4>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_send_wr__bindgen_ty_4))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).bind_mw as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_send_wr__bindgen_ty_4>())).tso as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_send_wr__bindgen_ty_4),
            "::",
            stringify!(tso)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_recv_wr {
    pub wr_id: u64,
    pub next: *mut ibv_recv_wr,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_recv_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_recv_wr>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_recv_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_recv_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).sg_list as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_recv_wr>())).num_sge as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_recv_wr),
            "::",
            stringify!(num_sge)
        )
    );
}
pub mod ibv_ops_wr_opcode {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_WR_TAG_ADD: Type = 0;
    pub const IBV_WR_TAG_DEL: Type = 1;
    pub const IBV_WR_TAG_SYNC: Type = 2;
}
impl ibv_ops_flags {
    pub const IBV_OPS_SIGNALED: ibv_ops_flags = ibv_ops_flags(1);
}
impl ibv_ops_flags {
    pub const IBV_OPS_TM_SYNC: ibv_ops_flags = ibv_ops_flags(2);
}
impl ::std::ops::BitOr<ibv_ops_flags> for ibv_ops_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_ops_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_ops_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_ops_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_ops_flags> for ibv_ops_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_ops_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_ops_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_ops_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_ops_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ops_wr {
    pub wr_id: u64,
    pub next: *mut ibv_ops_wr,
    pub opcode: ibv_ops_wr_opcode::Type,
    pub flags: ::std::os::raw::c_int,
    pub tm: ibv_ops_wr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1 {
    pub unexpected_cnt: u32,
    pub handle: u32,
    pub add: ibv_ops_wr__bindgen_ty_1__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ops_wr__bindgen_ty_1__bindgen_ty_1 {
    pub recv_wr_id: u64,
    pub sg_list: *mut ibv_sge,
    pub num_sge: ::std::os::raw::c_int,
    pub tag: u64,
    pub mask: u64,
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        40usize,
        concat!(
            "Size of: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).recv_wr_id
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(recv_wr_id)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).sg_list as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(sg_list)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).num_sge as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(num_sge)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).tag as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1__bindgen_ty_1>())).mask as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(mask)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_ops_wr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr__bindgen_ty_1>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).unexpected_cnt as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(unexpected_cnt)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).handle as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr__bindgen_ty_1>())).add as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr__bindgen_ty_1),
            "::",
            stringify!(add)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_ops_wr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ops_wr>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ops_wr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ops_wr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).next as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(next)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).opcode as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).flags as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ops_wr>())).tm as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ops_wr),
            "::",
            stringify!(tm)
        )
    );
}
#[repr(C)]
pub struct ibv_mw_bind {
    pub wr_id: u64,
    pub send_flags: ::std::os::raw::c_uint,
    pub bind_info: ibv_mw_bind_info,
}
#[test]
fn bindgen_test_layout_ibv_mw_bind() {
    assert_eq!(
        ::std::mem::size_of::<ibv_mw_bind>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_mw_bind>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_mw_bind))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).wr_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).send_flags as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(send_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_mw_bind>())).bind_info as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_mw_bind),
            "::",
            stringify!(bind_info)
        )
    );
}
#[repr(C)]
pub struct ibv_srq {
    pub context: *mut ibv_context,
    pub srq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub handle: u32,
    pub mutex: libc::pthread_mutex_t,
    pub cond: libc::pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_srq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_srq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_srq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_srq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_srq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).srq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(srq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_srq>())).events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_srq),
            "::",
            stringify!(events_completed)
        )
    );
}
#[repr(C)]
pub struct ibv_wq {
    pub context: *mut ibv_context,
    pub wq_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub cq: *mut ibv_cq,
    pub wq_num: u32,
    pub handle: u32,
    pub state: ibv_wq_state::Type,
    pub wq_type: ibv_wq_type::Type,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_wq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub mutex: libc::pthread_mutex_t,
    pub cond: libc::pthread_cond_t,
    pub events_completed: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_wq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wq>(),
        152usize,
        concat!("Size of: ", stringify!(ibv_wq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_num as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).handle as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).state as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).wq_type as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(wq_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).post_recv as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).mutex as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).cond as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).events_completed as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wq>())).comp_mask as *const _ as usize },
        148usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wq),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
pub struct ibv_qp {
    pub context: *mut ibv_context,
    pub qp_context: *mut ::std::os::raw::c_void,
    pub pd: *mut ibv_pd,
    pub send_cq: *mut ibv_cq,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub handle: u32,
    pub qp_num: u32,
    pub state: ibv_qp_state::Type,
    pub qp_type: ibv_qp_type::Type,
    pub mutex: libc::pthread_mutex_t,
    pub cond: libc::pthread_cond_t,
    pub events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_qp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp>(),
        160usize,
        concat!("Size of: ", stringify!(ibv_qp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).pd as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).send_cq as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).recv_cq as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).srq as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).handle as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_num as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).state as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).qp_type as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).mutex as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).cond as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp>())).events_completed as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp),
            "::",
            stringify!(events_completed)
        )
    );
}
#[repr(C)]
pub struct ibv_qp_ex {
    pub qp_base: ibv_qp,
    pub comp_mask: u64,
    pub wr_id: u64,
    pub wr_flags: ::std::os::raw::c_uint,
    pub wr_atomic_cmp_swp: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            rkey: u32,
            remote_addr: u64,
            compare: u64,
            swap: u64,
        ),
    >,
    pub wr_atomic_fetch_add: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, add: u64),
    >,
    pub wr_bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            mw: *mut ibv_mw,
            rkey: u32,
            bind_info: *const ibv_mw_bind_info,
        ),
    >,
    pub wr_local_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_rdma_read: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64),
    >,
    pub wr_rdma_write_imm: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, rkey: u32, remote_addr: u64, imm_data: __be32),
    >,
    pub wr_send: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_send_imm:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, imm_data: __be32)>,
    pub wr_send_inv:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, invalidate_rkey: u32)>,
    pub wr_send_tso: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            hdr: *mut ::std::os::raw::c_void,
            hdr_sz: u16,
            mss: u16,
        ),
    >,
    pub wr_set_ud_addr: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp_ex,
            ah: *mut ibv_ah,
            remote_qpn: u32,
            remote_qkey: u32,
        ),
    >,
    pub wr_set_xrc_srqn:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex, remote_srqn: u32)>,
    pub wr_set_inline_data: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, addr: *mut ::std::os::raw::c_void, length: usize),
    >,
    pub wr_set_inline_data_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_buf: usize, buf_list: *const ibv_data_buf),
    >,
    pub wr_set_sge: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, lkey: u32, addr: u64, length: u32),
    >,
    pub wr_set_sge_list: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp_ex, num_sge: usize, sg_list: *const ibv_sge),
    >,
    pub wr_start: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
    pub wr_complete:
        ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex) -> ::std::os::raw::c_int>,
    pub wr_abort: ::std::option::Option<unsafe extern "C" fn(qp: *mut ibv_qp_ex)>,
}
#[test]
fn bindgen_test_layout_ibv_qp_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_qp_ex>(),
        344usize,
        concat!("Size of: ", stringify!(ibv_qp_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_qp_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_qp_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).qp_base as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(qp_base)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).comp_mask as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_id as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_flags as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_atomic_cmp_swp as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_atomic_cmp_swp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_atomic_fetch_add as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_atomic_fetch_add)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_bind_mw as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_local_inv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_local_inv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_read as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_read)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_write as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_write)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_rdma_write_imm as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_rdma_write_imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_imm as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_imm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_inv as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_inv)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_send_tso as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_send_tso)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_ud_addr as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_ud_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_xrc_srqn as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_xrc_srqn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_inline_data as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_inline_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_inline_data_list as *const _ as usize
        },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_inline_data_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_sge as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_sge)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_set_sge_list as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_set_sge_list)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_start as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_start)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_complete as *const _ as usize },
        328usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_complete)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_qp_ex>())).wr_abort as *const _ as usize },
        336usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_qp_ex),
            "::",
            stringify!(wr_abort)
        )
    );
}
extern "C" {
    pub fn ibv_qp_to_qp_ex(qp: *mut ibv_qp) -> *mut ibv_qp_ex;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_comp_channel {
    pub context: *mut ibv_context,
    pub fd: ::std::os::raw::c_int,
    pub refcnt: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_comp_channel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_comp_channel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_comp_channel>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_comp_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).fd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_comp_channel>())).refcnt as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_comp_channel),
            "::",
            stringify!(refcnt)
        )
    );
}
#[repr(C)]
pub struct ibv_cq {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: libc::pthread_mutex_t,
    pub cond: libc::pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq>(),
        128usize,
        concat!("Size of: ", stringify!(ibv_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq>())).async_events_completed as *const _ as usize },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq),
            "::",
            stringify!(async_events_completed)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_poll_cq_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_poll_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_poll_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_poll_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_poll_cq_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_poll_cq_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_wc_tm_info {
    pub tag: u64,
    pub priv_: u32,
}
#[test]
fn bindgen_test_layout_ibv_wc_tm_info() {
    assert_eq!(
        ::std::mem::size_of::<ibv_wc_tm_info>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_wc_tm_info>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_wc_tm_info))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).tag as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_wc_tm_info>())).priv_ as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_wc_tm_info),
            "::",
            stringify!(priv_)
        )
    );
}
#[repr(C)]
pub struct ibv_cq_ex {
    pub context: *mut ibv_context,
    pub channel: *mut ibv_comp_channel,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub handle: u32,
    pub cqe: ::std::os::raw::c_int,
    pub mutex: libc::pthread_mutex_t,
    pub cond: libc::pthread_cond_t,
    pub comp_events_completed: u32,
    pub async_events_completed: u32,
    pub comp_mask: u32,
    pub status: ibv_wc_status::Type,
    pub wr_id: u64,
    pub start_poll: ::std::option::Option<
        unsafe extern "C" fn(
            current: *mut ibv_cq_ex,
            attr: *mut ibv_poll_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub next_poll: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_int,
    >,
    pub end_poll: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex)>,
    pub read_opcode:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ibv_wc_opcode::Type>,
    pub read_vendor_err:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_byte_len: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_imm_data:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> __be32>,
    pub read_qp_num: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_src_qp: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_wc_flags: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex) -> ::std::os::raw::c_uint,
    >,
    pub read_slid: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_sl: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_dlid_path_bits:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u8>,
    pub read_completion_ts:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
    pub read_cvlan: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u16>,
    pub read_flow_tag: ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u32>,
    pub read_tm_info: ::std::option::Option<
        unsafe extern "C" fn(current: *mut ibv_cq_ex, tm_info: *mut ibv_wc_tm_info),
    >,
    pub read_completion_wallclock_ns:
        ::std::option::Option<unsafe extern "C" fn(current: *mut ibv_cq_ex) -> u64>,
}
#[test]
fn bindgen_test_layout_ibv_cq_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_ex>(),
        288usize,
        concat!("Size of: ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cq_context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).handle as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cqe as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).mutex as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).cond as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(cond)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_events_completed as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_events_completed)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).async_events_completed as *const _ as usize
        },
        124usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(async_events_completed)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).comp_mask as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).status as *const _ as usize },
        132usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(status)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).wr_id as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(wr_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).start_poll as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(start_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).next_poll as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(next_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).end_poll as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(end_poll)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_opcode as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_opcode)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_vendor_err as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_vendor_err)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_byte_len as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_byte_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_imm_data as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_imm_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_qp_num as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_qp_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_src_qp as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_src_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_wc_flags as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_slid as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_sl as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_dlid_path_bits as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_dlid_path_bits)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_ts as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_ts)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_cvlan as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_cvlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_flow_tag as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_flow_tag)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_ex>())).read_tm_info as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_tm_info)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_cq_ex>())).read_completion_wallclock_ns as *const _ as usize
        },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_ex),
            "::",
            stringify!(read_completion_wallclock_ns)
        )
    );
}
impl ibv_cq_attr_mask {
    pub const IBV_CQ_ATTR_MODERATE: ibv_cq_attr_mask = ibv_cq_attr_mask(1);
}
impl ibv_cq_attr_mask {
    pub const IBV_CQ_ATTR_RESERVED: ibv_cq_attr_mask = ibv_cq_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_cq_attr_mask> for ibv_cq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_cq_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_cq_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_cq_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_cq_attr_mask> for ibv_cq_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_cq_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_cq_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_cq_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_cq_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_moderate_cq {
    pub cq_count: u16,
    pub cq_period: u16,
}
#[test]
fn bindgen_test_layout_ibv_moderate_cq() {
    assert_eq!(
        ::std::mem::size_of::<ibv_moderate_cq>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_moderate_cq>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_moderate_cq))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_moderate_cq>())).cq_period as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_moderate_cq),
            "::",
            stringify!(cq_period)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_modify_cq_attr {
    pub attr_mask: u32,
    pub moderate: ibv_moderate_cq,
}
#[test]
fn bindgen_test_layout_ibv_modify_cq_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_modify_cq_attr>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_modify_cq_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_modify_cq_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).attr_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(attr_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_modify_cq_attr>())).moderate as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_modify_cq_attr),
            "::",
            stringify!(moderate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_ah {
    pub context: *mut ibv_context,
    pub pd: *mut ibv_pd,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_ah() {
    assert_eq!(
        ::std::mem::size_of::<ibv_ah>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_ah))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_ah>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_ah))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).pd as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_ah>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_ah),
            "::",
            stringify!(handle)
        )
    );
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_ALLOW_LOOP_BACK: ibv_flow_flags = ibv_flow_flags(1);
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_DONT_TRAP: ibv_flow_flags = ibv_flow_flags(2);
}
impl ibv_flow_flags {
    pub const IBV_FLOW_ATTR_FLAGS_EGRESS: ibv_flow_flags = ibv_flow_flags(4);
}
impl ::std::ops::BitOr<ibv_flow_flags> for ibv_flow_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_flow_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_flow_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_flow_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_flow_flags> for ibv_flow_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_flow_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_flow_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_flow_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_flow_flags(pub ::std::os::raw::c_uint);
pub mod ibv_flow_attr_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_FLOW_ATTR_NORMAL: Type = 0;
    pub const IBV_FLOW_ATTR_ALL_DEFAULT: Type = 1;
    pub const IBV_FLOW_ATTR_MC_DEFAULT: Type = 2;
    pub const IBV_FLOW_ATTR_SNIFFER: Type = 3;
}
pub mod ibv_flow_spec_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_FLOW_SPEC_ETH: Type = 32;
    pub const IBV_FLOW_SPEC_IPV4: Type = 48;
    pub const IBV_FLOW_SPEC_IPV6: Type = 49;
    pub const IBV_FLOW_SPEC_IPV4_EXT: Type = 50;
    pub const IBV_FLOW_SPEC_ESP: Type = 52;
    pub const IBV_FLOW_SPEC_TCP: Type = 64;
    pub const IBV_FLOW_SPEC_UDP: Type = 65;
    pub const IBV_FLOW_SPEC_VXLAN_TUNNEL: Type = 80;
    pub const IBV_FLOW_SPEC_GRE: Type = 81;
    pub const IBV_FLOW_SPEC_MPLS: Type = 96;
    pub const IBV_FLOW_SPEC_INNER: Type = 256;
    pub const IBV_FLOW_SPEC_ACTION_TAG: Type = 4096;
    pub const IBV_FLOW_SPEC_ACTION_DROP: Type = 4097;
    pub const IBV_FLOW_SPEC_ACTION_HANDLE: Type = 4098;
    pub const IBV_FLOW_SPEC_ACTION_COUNT: Type = 4099;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_eth_filter {
    pub dst_mac: [u8; 6usize],
    pub src_mac: [u8; 6usize],
    pub ether_type: u16,
    pub vlan_tag: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_eth_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_eth_filter>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_eth_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_eth_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).dst_mac as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(dst_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).src_mac as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(src_mac)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).ether_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(ether_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_eth_filter>())).vlan_tag as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_eth_filter),
            "::",
            stringify!(vlan_tag)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_eth {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_eth_filter,
    pub mask: ibv_flow_eth_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_eth() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_eth>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_eth>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_eth))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_eth>())).mask as *const _ as usize },
        22usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_eth),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_ipv4_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_filter),
            "::",
            stringify!(dst_ip)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_ipv4 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv4_filter,
    pub mask: ibv_flow_ipv4_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_ipv4_ext_filter {
    pub src_ip: u32,
    pub dst_ip: u32,
    pub proto: u8,
    pub tos: u8,
    pub ttl: u8,
    pub flags: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv4_ext_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv4_ext_filter>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv4_ext_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv4_ext_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).dst_ip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).proto as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(proto)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).tos as *const _ as usize },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(tos)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).ttl as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(ttl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv4_ext_filter>())).flags as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv4_ext_filter),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_ipv4_ext {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv4_ext_filter,
    pub mask: ibv_flow_ipv4_ext_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv4_ext() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv4_ext>(),
        32usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv4_ext>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv4_ext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv4_ext>())).mask as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv4_ext),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_ipv6_filter {
    pub src_ip: [u8; 16usize],
    pub dst_ip: [u8; 16usize],
    pub flow_label: u32,
    pub next_hdr: u8,
    pub traffic_class: u8,
    pub hop_limit: u8,
}
#[test]
fn bindgen_test_layout_ibv_flow_ipv6_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_ipv6_filter>(),
        40usize,
        concat!("Size of: ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_ipv6_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_ipv6_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).src_ip as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(src_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).dst_ip as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(dst_ip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).flow_label as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).next_hdr as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(next_hdr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).traffic_class as *const _ as usize
        },
        37usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_ipv6_filter>())).hop_limit as *const _ as usize },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_ipv6_filter),
            "::",
            stringify!(hop_limit)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_ipv6 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_ipv6_filter,
    pub mask: ibv_flow_ipv6_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_ipv6() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_ipv6>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_ipv6>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_ipv6))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_ipv6>())).mask as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_ipv6),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_esp_filter {
    pub spi: u32,
    pub seq: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_esp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_esp_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_esp_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_esp_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).spi as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(spi)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_esp_filter>())).seq as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_esp_filter),
            "::",
            stringify!(seq)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_esp {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_esp_filter,
    pub mask: ibv_flow_esp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_esp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_esp>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_esp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_esp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_esp>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_esp),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_tcp_udp_filter {
    pub dst_port: u16,
    pub src_port: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_tcp_udp_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tcp_udp_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tcp_udp_filter>(),
        2usize,
        concat!("Alignment of ", stringify!(ibv_flow_tcp_udp_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).dst_port as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(dst_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tcp_udp_filter>())).src_port as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tcp_udp_filter),
            "::",
            stringify!(src_port)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_tcp_udp {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_tcp_udp_filter,
    pub mask: ibv_flow_tcp_udp_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tcp_udp() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tcp_udp>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tcp_udp>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tcp_udp))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).val as *const _ as usize },
        6usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tcp_udp>())).mask as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tcp_udp),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_gre_filter {
    pub c_ks_res0_ver: u16,
    pub protocol: u16,
    pub key: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_gre_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_gre_filter>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_gre_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_gre_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_gre_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_gre_filter>())).c_ks_res0_ver as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(c_ks_res0_ver)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_gre_filter>())).protocol as *const _ as usize },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(protocol)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_gre_filter>())).key as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_gre_filter),
            "::",
            stringify!(key)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_gre {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_gre_filter,
    pub mask: ibv_flow_gre_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_gre() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_gre>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_gre))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_gre>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_gre))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_gre>())).mask as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_gre),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_mpls_filter {
    pub label: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_mpls_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_mpls_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_mpls_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_mpls_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_mpls_filter))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_mpls_filter>())).label as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_mpls_filter),
            "::",
            stringify!(label)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_mpls {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_mpls_filter,
    pub mask: ibv_flow_mpls_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_mpls() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_mpls>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_mpls))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_mpls>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_mpls))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_mpls>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_mpls),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_tunnel_filter {
    pub tunnel_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_tunnel_filter() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_tunnel_filter>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_tunnel_filter))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_tunnel_filter>())).tunnel_id as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_tunnel_filter),
            "::",
            stringify!(tunnel_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_tunnel {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub val: ibv_flow_tunnel_filter,
    pub mask: ibv_flow_tunnel_filter,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_tunnel() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_tunnel>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_tunnel>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_tunnel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).val as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(val)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_tunnel>())).mask as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_tunnel),
            "::",
            stringify!(mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_action_tag {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub tag_id: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_tag() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_tag>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_tag>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_tag>())).tag_id as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_tag),
            "::",
            stringify!(tag_id)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_action_drop {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_drop() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_drop>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_drop>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_drop))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec_action_drop>())).size as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_drop),
            "::",
            stringify!(size)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_action_handle {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub action: *const ibv_flow_action,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_action_handle() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_action_handle>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_action_handle>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_action_handle))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_action_handle>())).action as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_action_handle),
            "::",
            stringify!(action)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec_counter_action {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
    pub counters: *mut ibv_counters,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec_counter_action() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec_counter_action>(),
        16usize,
        concat!("Size of: ", stringify!(ibv_flow_spec_counter_action))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec_counter_action>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec_counter_action))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).type_ as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec_counter_action>())).counters as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec_counter_action),
            "::",
            stringify!(counters)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec__bindgen_ty_1 {
    pub hdr: __BindgenUnionField<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>,
    pub eth: __BindgenUnionField<ibv_flow_spec_eth>,
    pub ipv4: __BindgenUnionField<ibv_flow_spec_ipv4>,
    pub tcp_udp: __BindgenUnionField<ibv_flow_spec_tcp_udp>,
    pub ipv4_ext: __BindgenUnionField<ibv_flow_spec_ipv4_ext>,
    pub ipv6: __BindgenUnionField<ibv_flow_spec_ipv6>,
    pub esp: __BindgenUnionField<ibv_flow_spec_esp>,
    pub tunnel: __BindgenUnionField<ibv_flow_spec_tunnel>,
    pub gre: __BindgenUnionField<ibv_flow_spec_gre>,
    pub mpls: __BindgenUnionField<ibv_flow_spec_mpls>,
    pub flow_tag: __BindgenUnionField<ibv_flow_spec_action_tag>,
    pub drop: __BindgenUnionField<ibv_flow_spec_action_drop>,
    pub handle: __BindgenUnionField<ibv_flow_spec_action_handle>,
    pub flow_count: __BindgenUnionField<ibv_flow_spec_counter_action>,
    pub bindgen_union_field: [u64; 11usize],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_spec__bindgen_ty_1__bindgen_ty_1 {
    pub type_: ibv_flow_spec_type::Type,
    pub size: u16,
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        8usize,
        concat!(
            "Size of: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).type_ as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1__bindgen_ty_1>())).size as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1__bindgen_ty_1),
            "::",
            stringify!(size)
        )
    );
}
#[test]
fn bindgen_test_layout_ibv_flow_spec__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_spec__bindgen_ty_1>(),
        88usize,
        concat!("Size of: ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_spec__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_spec__bindgen_ty_1))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).hdr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(hdr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).eth as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(eth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tcp_udp as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tcp_udp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv4_ext as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv4_ext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).ipv6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(ipv6)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).esp as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).tunnel as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(tunnel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).gre as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(gre)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).mpls as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(mpls)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).flow_tag as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(flow_tag)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).drop as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(drop)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).handle as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(handle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_spec__bindgen_ty_1>())).flow_count as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_spec__bindgen_ty_1),
            "::",
            stringify!(flow_count)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_attr {
    pub comp_mask: u32,
    pub type_: ibv_flow_attr_type::Type,
    pub size: u16,
    pub priority: u16,
    pub num_of_specs: u8,
    pub port: u8,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_attr>(),
        20usize,
        concat!("Size of: ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_flow_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).type_ as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).size as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).priority as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(priority)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).num_of_specs as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(num_of_specs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).port as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_attr>())).flags as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_attr),
            "::",
            stringify!(flags)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow {
    pub comp_mask: u32,
    pub context: *mut ibv_context,
    pub handle: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_flow))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow>())).handle as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow),
            "::",
            stringify!(handle)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_action {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_flow_action() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action),
            "::",
            stringify!(context)
        )
    );
}
impl ibv_flow_action_esp_mask {
    pub const IBV_FLOW_ACTION_ESP_MASK_ESN: ibv_flow_action_esp_mask = ibv_flow_action_esp_mask(1);
}
impl ::std::ops::BitOr<ibv_flow_action_esp_mask> for ibv_flow_action_esp_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_flow_action_esp_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_flow_action_esp_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_flow_action_esp_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_flow_action_esp_mask> for ibv_flow_action_esp_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_flow_action_esp_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_flow_action_esp_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_flow_action_esp_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_flow_action_esp_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_flow_action_esp_attr {
    pub esp_attr: *mut ib_uverbs_flow_action_esp,
    pub keymat_proto: ib_uverbs_flow_action_esp_keymat,
    pub keymat_len: u16,
    pub keymat_ptr: *mut ::std::os::raw::c_void,
    pub replay_proto: ib_uverbs_flow_action_esp_replay,
    pub replay_len: u16,
    pub replay_ptr: *mut ::std::os::raw::c_void,
    pub esp_encap: *mut ib_uverbs_flow_action_esp_encap,
    pub comp_mask: u32,
    pub esn: u32,
}
#[test]
fn bindgen_test_layout_ibv_flow_action_esp_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_flow_action_esp_attr>(),
        56usize,
        concat!("Size of: ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_flow_action_esp_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_flow_action_esp_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_attr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_attr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_proto as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_len as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).keymat_ptr as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(keymat_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_proto as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_proto)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_len as *const _ as usize
        },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).replay_ptr as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(replay_ptr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esp_encap as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esp_encap)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).comp_mask as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_flow_action_esp_attr>())).esn as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_flow_action_esp_attr),
            "::",
            stringify!(esn)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _ibv_device_ops {
    pub _dummy1: ::std::option::Option<
        unsafe extern "C" fn(
            device: *mut ibv_device,
            cmd_fd: ::std::os::raw::c_int,
        ) -> *mut ibv_context,
    >,
    pub _dummy2: ::std::option::Option<unsafe extern "C" fn(context: *mut ibv_context)>,
}
#[test]
fn bindgen_test_layout__ibv_device_ops() {
    assert_eq!(
        ::std::mem::size_of::<_ibv_device_ops>(),
        16usize,
        concat!("Size of: ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<_ibv_device_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(_ibv_device_ops))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<_ibv_device_ops>()))._dummy2 as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_ibv_device_ops),
            "::",
            stringify!(_dummy2)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_device {
    pub _ops: _ibv_device_ops,
    pub node_type: ibv_node_type::Type,
    pub transport_type: ibv_transport_type::Type,
    pub name: [::std::os::raw::c_char; 64usize],
    pub dev_name: [::std::os::raw::c_char; 64usize],
    pub dev_path: [::std::os::raw::c_char; 256usize],
    pub ibdev_path: [::std::os::raw::c_char; 256usize],
}
#[test]
fn bindgen_test_layout_ibv_device() {
    assert_eq!(
        ::std::mem::size_of::<ibv_device>(),
        664usize,
        concat!("Size of: ", stringify!(ibv_device))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_device>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_device))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>()))._ops as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(_ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).node_type as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(node_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).transport_type as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(transport_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).name as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_name as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).dev_path as *const _ as usize },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(dev_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_device>())).ibdev_path as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_device),
            "::",
            stringify!(ibdev_path)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct _compat_ibv_port_attr {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_context_ops {
    pub _compat_query_device:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut _compat_ibv_port_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_alloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dealloc_pd:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_reg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_rereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_dereg_mr:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub alloc_mw: ::std::option::Option<
        unsafe extern "C" fn(pd: *mut ibv_pd, type_: ibv_mw_type::Type) -> *mut ibv_mw,
    >,
    pub bind_mw: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            mw: *mut ibv_mw,
            mw_bind: *mut ibv_mw_bind,
        ) -> ::std::os::raw::c_int,
    >,
    pub dealloc_mw:
        ::std::option::Option<unsafe extern "C" fn(mw: *mut ibv_mw) -> ::std::os::raw::c_int>,
    pub _compat_create_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub poll_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            num_entries: ::std::os::raw::c_int,
            wc: *mut ibv_wc,
        ) -> ::std::os::raw::c_int,
    >,
    pub req_notify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            solicited_only: ::std::os::raw::c_int,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_cq_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_resize_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_cq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_create_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_srq:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_srq_recv: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            recv_wr: *mut ibv_recv_wr,
            bad_recv_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_query_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_modify_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_qp:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub post_send: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_send_wr,
            bad_wr: *mut *mut ibv_send_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_recv: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            wr: *mut ibv_recv_wr,
            bad_wr: *mut *mut ibv_recv_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub _compat_create_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_destroy_ah:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_attach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_detach_mcast:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
    pub _compat_async_event:
        ::std::option::Option<unsafe extern "C" fn() -> *mut ::std::os::raw::c_void>,
}
#[test]
fn bindgen_test_layout_ibv_context_ops() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context_ops>(),
        256usize,
        concat!("Size of: ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context_ops>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context_ops))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_device as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_device)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_port as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_port)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_alloc_pd as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_alloc_pd)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_dealloc_pd as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_dealloc_pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>()))._compat_reg_mr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_reg_mr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_rereg_mr as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_rereg_mr)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_dereg_mr as *const _ as usize
        },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_dereg_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).alloc_mw as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(alloc_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).bind_mw as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(bind_mw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).dealloc_mw as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(dealloc_mw)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_cq as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).poll_cq as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(poll_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).req_notify_cq as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(req_notify_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_cq_event as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_cq_event)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_resize_cq as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_resize_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_cq as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_cq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_srq as *const _ as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_modify_srq as *const _ as usize
        },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_modify_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_srq as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_srq)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_srq as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_srq_recv as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_srq_recv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_qp as *const _ as usize
        },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_query_qp as *const _ as usize
        },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_query_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_modify_qp as *const _ as usize
        },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_modify_qp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_qp as *const _ as usize
        },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_send as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_send)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context_ops>())).post_recv as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(post_recv)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_create_ah as *const _ as usize
        },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_create_ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_destroy_ah as *const _ as usize
        },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_destroy_ah)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_attach_mcast as *const _ as usize
        },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_attach_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_detach_mcast as *const _ as usize
        },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_detach_mcast)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_context_ops>()))._compat_async_event as *const _ as usize
        },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context_ops),
            "::",
            stringify!(_compat_async_event)
        )
    );
}
#[repr(C)]
pub struct ibv_context {
    pub device: *mut ibv_device,
    pub ops: ibv_context_ops,
    pub cmd_fd: ::std::os::raw::c_int,
    pub async_fd: ::std::os::raw::c_int,
    pub num_comp_vectors: ::std::os::raw::c_int,
    pub mutex: libc::pthread_mutex_t,
    pub abi_compat: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ibv_context() {
    assert_eq!(
        ::std::mem::size_of::<ibv_context>(),
        328usize,
        concat!("Size of: ", stringify!(ibv_context))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_context>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).device as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(device)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).ops as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(ops)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).cmd_fd as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(cmd_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).async_fd as *const _ as usize },
        268usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(async_fd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).num_comp_vectors as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(num_comp_vectors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).mutex as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(mutex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_context>())).abi_compat as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_context),
            "::",
            stringify!(abi_compat)
        )
    );
}
impl ibv_cq_init_attr_mask {
    pub const IBV_CQ_INIT_ATTR_MASK_FLAGS: ibv_cq_init_attr_mask = ibv_cq_init_attr_mask(1);
}
impl ::std::ops::BitOr<ibv_cq_init_attr_mask> for ibv_cq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_cq_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_cq_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_cq_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_cq_init_attr_mask> for ibv_cq_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_cq_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_cq_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_cq_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_cq_init_attr_mask(pub ::std::os::raw::c_uint);
impl ibv_create_cq_attr_flags {
    pub const IBV_CREATE_CQ_ATTR_SINGLE_THREADED: ibv_create_cq_attr_flags =
        ibv_create_cq_attr_flags(1);
}
impl ibv_create_cq_attr_flags {
    pub const IBV_CREATE_CQ_ATTR_IGNORE_OVERRUN: ibv_create_cq_attr_flags =
        ibv_create_cq_attr_flags(2);
}
impl ::std::ops::BitOr<ibv_create_cq_attr_flags> for ibv_create_cq_attr_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_create_cq_attr_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_create_cq_attr_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_create_cq_attr_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_create_cq_attr_flags> for ibv_create_cq_attr_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_create_cq_attr_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_create_cq_attr_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_create_cq_attr_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_create_cq_attr_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_cq_init_attr_ex {
    pub cqe: u32,
    pub cq_context: *mut ::std::os::raw::c_void,
    pub channel: *mut ibv_comp_channel,
    pub comp_vector: u32,
    pub wc_flags: u64,
    pub comp_mask: u32,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_ibv_cq_init_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_cq_init_attr_ex>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_cq_init_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_cq_init_attr_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cqe as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cqe)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).cq_context as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(cq_context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).channel as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_vector as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_vector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).wc_flags as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(wc_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).comp_mask as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_cq_init_attr_ex>())).flags as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_cq_init_attr_ex),
            "::",
            stringify!(flags)
        )
    );
}
impl ibv_parent_domain_init_attr_mask {
    pub const IBV_PARENT_DOMAIN_INIT_ATTR_ALLOCATORS: ibv_parent_domain_init_attr_mask =
        ibv_parent_domain_init_attr_mask(1);
}
impl ibv_parent_domain_init_attr_mask {
    pub const IBV_PARENT_DOMAIN_INIT_ATTR_PD_CONTEXT: ibv_parent_domain_init_attr_mask =
        ibv_parent_domain_init_attr_mask(2);
}
impl ::std::ops::BitOr<ibv_parent_domain_init_attr_mask> for ibv_parent_domain_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_parent_domain_init_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_parent_domain_init_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_parent_domain_init_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_parent_domain_init_attr_mask> for ibv_parent_domain_init_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_parent_domain_init_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_parent_domain_init_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_parent_domain_init_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_parent_domain_init_attr_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_parent_domain_init_attr {
    pub pd: *mut ibv_pd,
    pub td: *mut ibv_td,
    pub comp_mask: u32,
    pub alloc: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            size: usize,
            alignment: usize,
            resource_type: u64,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            pd_context: *mut ::std::os::raw::c_void,
            ptr: *mut ::std::os::raw::c_void,
            resource_type: u64,
        ),
    >,
    pub pd_context: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_ibv_parent_domain_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_parent_domain_init_attr>(),
        48usize,
        concat!("Size of: ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_parent_domain_init_attr>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_parent_domain_init_attr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).pd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).td as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(td)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).comp_mask as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).alloc as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(alloc)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).free as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_parent_domain_init_attr>())).pd_context as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_parent_domain_init_attr),
            "::",
            stringify!(pd_context)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counters_init_attr {
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_counters_init_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counters_init_attr>(),
        4usize,
        concat!("Size of: ", stringify!(ibv_counters_init_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counters_init_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_counters_init_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counters_init_attr>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counters_init_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counters {
    pub context: *mut ibv_context,
}
#[test]
fn bindgen_test_layout_ibv_counters() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counters>(),
        8usize,
        concat!("Size of: ", stringify!(ibv_counters))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counters>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_counters))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_counters>())).context as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counters),
            "::",
            stringify!(context)
        )
    );
}
pub mod ibv_counter_description {
    pub type Type = ::std::os::raw::c_uint;
    pub const IBV_COUNTER_PACKETS: Type = 0;
    pub const IBV_COUNTER_BYTES: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct ibv_counter_attach_attr {
    pub counter_desc: ibv_counter_description::Type,
    pub index: u32,
    pub comp_mask: u32,
}
#[test]
fn bindgen_test_layout_ibv_counter_attach_attr() {
    assert_eq!(
        ::std::mem::size_of::<ibv_counter_attach_attr>(),
        12usize,
        concat!("Size of: ", stringify!(ibv_counter_attach_attr))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_counter_attach_attr>(),
        4usize,
        concat!("Alignment of ", stringify!(ibv_counter_attach_attr))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counter_attach_attr>())).counter_desc as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(counter_desc)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_counter_attach_attr>())).index as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_counter_attach_attr>())).comp_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_counter_attach_attr),
            "::",
            stringify!(comp_mask)
        )
    );
}
impl ibv_read_counters_flags {
    pub const IBV_READ_COUNTERS_ATTR_PREFER_CACHED: ibv_read_counters_flags =
        ibv_read_counters_flags(1);
}
impl ::std::ops::BitOr<ibv_read_counters_flags> for ibv_read_counters_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_read_counters_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_read_counters_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_read_counters_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_read_counters_flags> for ibv_read_counters_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_read_counters_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_read_counters_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_read_counters_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_read_counters_flags(pub ::std::os::raw::c_uint);
impl ibv_values_mask {
    pub const IBV_VALUES_MASK_RAW_CLOCK: ibv_values_mask = ibv_values_mask(1);
}
impl ibv_values_mask {
    pub const IBV_VALUES_MASK_RESERVED: ibv_values_mask = ibv_values_mask(2);
}
impl ::std::ops::BitOr<ibv_values_mask> for ibv_values_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        ibv_values_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for ibv_values_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: ibv_values_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<ibv_values_mask> for ibv_values_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        ibv_values_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for ibv_values_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: ibv_values_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct ibv_values_mask(pub ::std::os::raw::c_uint);
#[repr(C)]
pub struct ibv_values_ex {
    pub comp_mask: u32,
    pub raw_clock: libc::timespec,
}
#[test]
fn bindgen_test_layout_ibv_values_ex() {
    assert_eq!(
        ::std::mem::size_of::<ibv_values_ex>(),
        24usize,
        concat!("Size of: ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_values_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_values_ex))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).comp_mask as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_values_ex>())).raw_clock as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_values_ex),
            "::",
            stringify!(raw_clock)
        )
    );
}
#[repr(C)]
pub struct verbs_context {
    pub query_port: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            port_num: u8,
            port_attr: *mut ibv_port_attr,
            port_attr_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub advise_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            advice: ib_uverbs_advise_mr_advice::Type,
            flags: u32,
            sg_list: *mut ibv_sge,
            num_sges: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub alloc_null_mr: ::std::option::Option<unsafe extern "C" fn(pd: *mut ibv_pd) -> *mut ibv_mr>,
    pub read_counters: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            counters_value: *mut u64,
            ncounters: u32,
            flags: u32,
        ) -> ::std::os::raw::c_int,
    >,
    pub attach_counters_point_flow: ::std::option::Option<
        unsafe extern "C" fn(
            counters: *mut ibv_counters,
            attr: *mut ibv_counter_attach_attr,
            flow: *mut ibv_flow,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_counters: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_counters_init_attr,
        ) -> *mut ibv_counters,
    >,
    pub destroy_counters: ::std::option::Option<
        unsafe extern "C" fn(counters: *mut ibv_counters) -> ::std::os::raw::c_int,
    >,
    pub reg_dm_mr: ::std::option::Option<
        unsafe extern "C" fn(
            pd: *mut ibv_pd,
            dm: *mut ibv_dm,
            dm_offset: u64,
            length: usize,
            access: ::std::os::raw::c_uint,
        ) -> *mut ibv_mr,
    >,
    pub alloc_dm: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_alloc_dm_attr,
        ) -> *mut ibv_dm,
    >,
    pub free_dm:
        ::std::option::Option<unsafe extern "C" fn(dm: *mut ibv_dm) -> ::std::os::raw::c_int>,
    pub modify_flow_action_esp: ::std::option::Option<
        unsafe extern "C" fn(
            action: *mut ibv_flow_action,
            attr: *mut ibv_flow_action_esp_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_flow_action: ::std::option::Option<
        unsafe extern "C" fn(action: *mut ibv_flow_action) -> ::std::os::raw::c_int,
    >,
    pub create_flow_action_esp: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_flow_action_esp_attr,
        ) -> *mut ibv_flow_action,
    >,
    pub modify_qp_rate_limit: ::std::option::Option<
        unsafe extern "C" fn(
            qp: *mut ibv_qp,
            attr: *mut ibv_qp_rate_limit_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub alloc_parent_domain: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            attr: *mut ibv_parent_domain_init_attr,
        ) -> *mut ibv_pd,
    >,
    pub dealloc_td:
        ::std::option::Option<unsafe extern "C" fn(td: *mut ibv_td) -> ::std::os::raw::c_int>,
    pub alloc_td: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_td_init_attr,
        ) -> *mut ibv_td,
    >,
    pub modify_cq: ::std::option::Option<
        unsafe extern "C" fn(
            cq: *mut ibv_cq,
            attr: *mut ibv_modify_cq_attr,
        ) -> ::std::os::raw::c_int,
    >,
    pub post_srq_ops: ::std::option::Option<
        unsafe extern "C" fn(
            srq: *mut ibv_srq,
            op: *mut ibv_ops_wr,
            bad_op: *mut *mut ibv_ops_wr,
        ) -> ::std::os::raw::c_int,
    >,
    pub destroy_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(rwq_ind_table: *mut ibv_rwq_ind_table) -> ::std::os::raw::c_int,
    >,
    pub create_rwq_ind_table: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_rwq_ind_table_init_attr,
        ) -> *mut ibv_rwq_ind_table,
    >,
    pub destroy_wq:
        ::std::option::Option<unsafe extern "C" fn(wq: *mut ibv_wq) -> ::std::os::raw::c_int>,
    pub modify_wq: ::std::option::Option<
        unsafe extern "C" fn(wq: *mut ibv_wq, wq_attr: *mut ibv_wq_attr) -> ::std::os::raw::c_int,
    >,
    pub create_wq: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            wq_init_attr: *mut ibv_wq_init_attr,
        ) -> *mut ibv_wq,
    >,
    pub query_rt_values: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            values: *mut ibv_values_ex,
        ) -> ::std::os::raw::c_int,
    >,
    pub create_cq_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            init_attr: *mut ibv_cq_init_attr_ex,
        ) -> *mut ibv_cq_ex,
    >,
    pub priv_: *mut verbs_ex_private,
    pub query_device_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            input: *const ibv_query_device_ex_input,
            attr: *mut ibv_device_attr_ex,
            attr_size: usize,
        ) -> ::std::os::raw::c_int,
    >,
    pub ibv_destroy_flow:
        ::std::option::Option<unsafe extern "C" fn(flow: *mut ibv_flow) -> ::std::os::raw::c_int>,
    pub ABI_placeholder2: ::std::option::Option<unsafe extern "C" fn()>,
    pub ibv_create_flow: ::std::option::Option<
        unsafe extern "C" fn(qp: *mut ibv_qp, flow_attr: *mut ibv_flow_attr) -> *mut ibv_flow,
    >,
    pub ABI_placeholder1: ::std::option::Option<unsafe extern "C" fn()>,
    pub open_qp: ::std::option::Option<
        unsafe extern "C" fn(context: *mut ibv_context, attr: *mut ibv_qp_open_attr) -> *mut ibv_qp,
    >,
    pub create_qp_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            qp_init_attr_ex: *mut ibv_qp_init_attr_ex,
        ) -> *mut ibv_qp,
    >,
    pub get_srq_num: ::std::option::Option<
        unsafe extern "C" fn(srq: *mut ibv_srq, srq_num: *mut u32) -> ::std::os::raw::c_int,
    >,
    pub create_srq_ex: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            srq_init_attr_ex: *mut ibv_srq_init_attr_ex,
        ) -> *mut ibv_srq,
    >,
    pub open_xrcd: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut ibv_context,
            xrcd_init_attr: *mut ibv_xrcd_init_attr,
        ) -> *mut ibv_xrcd,
    >,
    pub close_xrcd:
        ::std::option::Option<unsafe extern "C" fn(xrcd: *mut ibv_xrcd) -> ::std::os::raw::c_int>,
    pub _ABI_placeholder3: u64,
    pub sz: usize,
    pub context: ibv_context,
}
#[test]
fn bindgen_test_layout_verbs_context() {
    assert_eq!(
        ::std::mem::size_of::<verbs_context>(),
        648usize,
        concat!("Size of: ", stringify!(verbs_context))
    );
    assert_eq!(
        ::std::mem::align_of::<verbs_context>(),
        8usize,
        concat!("Alignment of ", stringify!(verbs_context))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).query_port as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(query_port)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).advise_mr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(advise_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).alloc_null_mr as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(alloc_null_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).read_counters as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(read_counters)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).attach_counters_point_flow as *const _
                as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(attach_counters_point_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).create_counters as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_counters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).destroy_counters as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(destroy_counters)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).reg_dm_mr as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(reg_dm_mr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).alloc_dm as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(alloc_dm)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).free_dm as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(free_dm)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).modify_flow_action_esp as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(modify_flow_action_esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).destroy_flow_action as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(destroy_flow_action)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).create_flow_action_esp as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_flow_action_esp)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).modify_qp_rate_limit as *const _ as usize
        },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(modify_qp_rate_limit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).alloc_parent_domain as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(alloc_parent_domain)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).dealloc_td as *const _ as usize },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(dealloc_td)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).alloc_td as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(alloc_td)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).modify_cq as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(modify_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).post_srq_ops as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(post_srq_ops)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).destroy_rwq_ind_table as *const _ as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(destroy_rwq_ind_table)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<verbs_context>())).create_rwq_ind_table as *const _ as usize
        },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_rwq_ind_table)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).destroy_wq as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(destroy_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).modify_wq as *const _ as usize },
        176usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(modify_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).create_wq as *const _ as usize },
        184usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_wq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).query_rt_values as *const _ as usize },
        192usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(query_rt_values)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).create_cq_ex as *const _ as usize },
        200usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_cq_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).priv_ as *const _ as usize },
        208usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(priv_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).query_device_ex as *const _ as usize },
        216usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(query_device_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).ibv_destroy_flow as *const _ as usize },
        224usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(ibv_destroy_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).ABI_placeholder2 as *const _ as usize },
        232usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(ABI_placeholder2)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).ibv_create_flow as *const _ as usize },
        240usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(ibv_create_flow)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).ABI_placeholder1 as *const _ as usize },
        248usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(ABI_placeholder1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).open_qp as *const _ as usize },
        256usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(open_qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).create_qp_ex as *const _ as usize },
        264usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_qp_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).get_srq_num as *const _ as usize },
        272usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(get_srq_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).create_srq_ex as *const _ as usize },
        280usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(create_srq_ex)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).open_xrcd as *const _ as usize },
        288usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(open_xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).close_xrcd as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(close_xrcd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>()))._ABI_placeholder3 as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(_ABI_placeholder3)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).sz as *const _ as usize },
        312usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(sz)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<verbs_context>())).context as *const _ as usize },
        320usize,
        concat!(
            "Offset of field: ",
            stringify!(verbs_context),
            "::",
            stringify!(context)
        )
    );
}
extern "C" {
    pub fn ibv_get_device_list(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_device;
}
extern "C" {
    pub fn ibv_free_device_list(list: *mut *mut ibv_device);
}
extern "C" {
    pub fn ibv_get_device_name(device: *mut ibv_device) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_get_device_guid(device: *mut ibv_device) -> __be64;
}
extern "C" {
    pub fn ibv_open_device(device: *mut ibv_device) -> *mut ibv_context;
}
extern "C" {
    pub fn ibv_close_device(context: *mut ibv_context) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_get_async_event(
        context: *mut ibv_context,
        event: *mut ibv_async_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_ack_async_event(event: *mut ibv_async_event);
}
extern "C" {
    pub fn ibv_query_device(
        context: *mut ibv_context,
        device_attr: *mut ibv_device_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_query_port(
        context: *mut ibv_context,
        port_num: u8,
        port_attr: *mut _compat_ibv_port_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_query_gid(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        gid: *mut ibv_gid,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_query_pkey(
        context: *mut ibv_context,
        port_num: u8,
        index: ::std::os::raw::c_int,
        pkey: *mut __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_get_pkey_index(
        context: *mut ibv_context,
        port_num: u8,
        pkey: __be16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_alloc_pd(context: *mut ibv_context) -> *mut ibv_pd;
}
extern "C" {
    pub fn ibv_dealloc_pd(pd: *mut ibv_pd) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_reg_mr_iova2(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        iova: u64,
        access: ::std::os::raw::c_uint,
    ) -> *mut ibv_mr;
}
extern "C" {
    pub fn ibv_reg_mr(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
extern "C" {
    pub fn ibv_reg_mr_iova(
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        iova: u64,
        access: ::std::os::raw::c_int,
    ) -> *mut ibv_mr;
}
pub mod ibv_rereg_mr_err_code {
    pub type Type = ::std::os::raw::c_int;
    pub const IBV_REREG_MR_ERR_INPUT: Type = -1;
    pub const IBV_REREG_MR_ERR_DONT_FORK_NEW: Type = -2;
    pub const IBV_REREG_MR_ERR_DO_FORK_OLD: Type = -3;
    pub const IBV_REREG_MR_ERR_CMD: Type = -4;
    pub const IBV_REREG_MR_ERR_CMD_AND_DO_FORK_NEW: Type = -5;
}
extern "C" {
    pub fn ibv_rereg_mr(
        mr: *mut ibv_mr,
        flags: ::std::os::raw::c_int,
        pd: *mut ibv_pd,
        addr: *mut ::std::os::raw::c_void,
        length: usize,
        access: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_dereg_mr(mr: *mut ibv_mr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_create_comp_channel(context: *mut ibv_context) -> *mut ibv_comp_channel;
}
extern "C" {
    pub fn ibv_destroy_comp_channel(channel: *mut ibv_comp_channel) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_create_cq(
        context: *mut ibv_context,
        cqe: ::std::os::raw::c_int,
        cq_context: *mut ::std::os::raw::c_void,
        channel: *mut ibv_comp_channel,
        comp_vector: ::std::os::raw::c_int,
    ) -> *mut ibv_cq;
}
extern "C" {
    pub fn ibv_resize_cq(cq: *mut ibv_cq, cqe: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_destroy_cq(cq: *mut ibv_cq) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_get_cq_event(
        channel: *mut ibv_comp_channel,
        cq: *mut *mut ibv_cq,
        cq_context: *mut *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_ack_cq_events(cq: *mut ibv_cq, nevents: ::std::os::raw::c_uint);
}
extern "C" {
    pub fn ibv_create_srq(pd: *mut ibv_pd, srq_init_attr: *mut ibv_srq_init_attr) -> *mut ibv_srq;
}
extern "C" {
    pub fn ibv_modify_srq(
        srq: *mut ibv_srq,
        srq_attr: *mut ibv_srq_attr,
        srq_attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_query_srq(srq: *mut ibv_srq, srq_attr: *mut ibv_srq_attr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_destroy_srq(srq: *mut ibv_srq) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_create_qp(pd: *mut ibv_pd, qp_init_attr: *mut ibv_qp_init_attr) -> *mut ibv_qp;
}
extern "C" {
    pub fn ibv_modify_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_query_qp(
        qp: *mut ibv_qp,
        attr: *mut ibv_qp_attr,
        attr_mask: ::std::os::raw::c_int,
        init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_destroy_qp(qp: *mut ibv_qp) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_create_ah(pd: *mut ibv_pd, attr: *mut ibv_ah_attr) -> *mut ibv_ah;
}
extern "C" {
    pub fn ibv_init_ah_from_wc(
        context: *mut ibv_context,
        port_num: u8,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        ah_attr: *mut ibv_ah_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_create_ah_from_wc(
        pd: *mut ibv_pd,
        wc: *mut ibv_wc,
        grh: *mut ibv_grh,
        port_num: u8,
    ) -> *mut ibv_ah;
}
extern "C" {
    pub fn ibv_destroy_ah(ah: *mut ibv_ah) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_attach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_detach_mcast(
        qp: *mut ibv_qp,
        gid: *const ibv_gid,
        lid: u16,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_fork_init() -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ibv_node_type_str(node_type: ibv_node_type::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_port_state_str(port_state: ibv_port_state::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_event_type_str(event: ibv_event_type::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn ibv_resolve_eth_l2_from_gid(
        context: *mut ibv_context,
        attr: *mut ibv_ah_attr,
        eth_mac: *mut u8,
        vid: *mut u16,
    ) -> ::std::os::raw::c_int;
}
pub type socklen_t = __socklen_t;
pub type sa_family_t = ::std::os::raw::c_ushort;
pub type in_addr_t = u32;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in_addr {
    pub s_addr: in_addr_t,
}
#[test]
fn bindgen_test_layout_in_addr() {
    assert_eq!(
        ::std::mem::size_of::<in_addr>(),
        4usize,
        concat!("Size of: ", stringify!(in_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in_addr>())).s_addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in_addr),
            "::",
            stringify!(s_addr)
        )
    );
}
pub type in_port_t = u16;
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr {
    pub __in6_u: in6_addr__bindgen_ty_1,
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct in6_addr__bindgen_ty_1 {
    pub __u6_addr8: __BindgenUnionField<[u8; 16usize]>,
    pub __u6_addr16: __BindgenUnionField<[u16; 8usize]>,
    pub __u6_addr32: __BindgenUnionField<[u32; 4usize]>,
    pub bindgen_union_field: [u32; 4usize],
}
#[test]
fn bindgen_test_layout_in6_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr8 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr8)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr16 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr16)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<in6_addr__bindgen_ty_1>())).__u6_addr32 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr__bindgen_ty_1),
            "::",
            stringify!(__u6_addr32)
        )
    );
}
#[test]
fn bindgen_test_layout_in6_addr() {
    assert_eq!(
        ::std::mem::size_of::<in6_addr>(),
        16usize,
        concat!("Size of: ", stringify!(in6_addr))
    );
    assert_eq!(
        ::std::mem::align_of::<in6_addr>(),
        4usize,
        concat!("Alignment of ", stringify!(in6_addr))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<in6_addr>())).__in6_u as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(in6_addr),
            "::",
            stringify!(__in6_u)
        )
    );
}
#[repr(C)]
pub struct ibv_sa_path_rec {
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub raw_traffic: ::std::os::raw::c_int,
    pub flow_label: __be32,
    pub hop_limit: u8,
    pub traffic_class: u8,
    pub reversible: ::std::os::raw::c_int,
    pub numb_path: u8,
    pub pkey: __be16,
    pub sl: u8,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub preference: u8,
}
#[test]
fn bindgen_test_layout_ibv_sa_path_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_path_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_path_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_path_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sgid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).dlid as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).slid as *const _ as usize },
        34usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).raw_traffic as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(raw_traffic)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).flow_label as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).hop_limit as *const _ as usize },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).traffic_class as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).reversible as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(reversible)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).numb_path as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(numb_path)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).pkey as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).sl as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu_selector as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).mtu as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate_selector as *const _ as usize },
        59usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).rate as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time_selector as *const _
                as usize
        },
        61usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_path_rec>())).packet_life_time as *const _ as usize
        },
        62usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_path_rec>())).preference as *const _ as usize },
        63usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_path_rec),
            "::",
            stringify!(preference)
        )
    );
}
#[repr(C)]
pub struct ibv_sa_mcmember_rec {
    pub mgid: ibv_gid,
    pub port_gid: ibv_gid,
    pub qkey: u32,
    pub mlid: u16,
    pub mtu_selector: u8,
    pub mtu: u8,
    pub traffic_class: u8,
    pub pkey: u16,
    pub rate_selector: u8,
    pub rate: u8,
    pub packet_life_time_selector: u8,
    pub packet_life_time: u8,
    pub sl: u8,
    pub flow_label: u32,
    pub hop_limit: u8,
    pub scope: u8,
    pub join_state: u8,
    pub proxy_join: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_ibv_sa_mcmember_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_mcmember_rec>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_mcmember_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_mcmember_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mgid as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).port_gid as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(port_gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).qkey as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(qkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mlid as *const _ as usize },
        36usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mlid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu_selector as *const _ as usize
        },
        38usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).mtu as *const _ as usize },
        39usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).traffic_class as *const _ as usize
        },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(traffic_class)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).pkey as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate_selector as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate_selector)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).rate as *const _ as usize },
        45usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time_selector as *const _
                as usize
        },
        46usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time_selector)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).packet_life_time as *const _ as usize
        },
        47usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(packet_life_time)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).sl as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).flow_label as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(flow_label)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).hop_limit as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(hop_limit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).scope as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(scope)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).join_state as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(join_state)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_mcmember_rec>())).proxy_join as *const _ as usize },
        60usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_mcmember_rec),
            "::",
            stringify!(proxy_join)
        )
    );
}
#[repr(C)]
pub struct ibv_sa_service_rec {
    pub id: u64,
    pub gid: ibv_gid,
    pub pkey: u16,
    pub lease: u32,
    pub key: [u8; 16usize],
    pub name: [u8; 64usize],
    pub data8: [u8; 16usize],
    pub data16: [u16; 8usize],
    pub data32: [u32; 4usize],
    pub data64: [u64; 2usize],
}
#[test]
fn bindgen_test_layout_ibv_sa_service_rec() {
    assert_eq!(
        ::std::mem::size_of::<ibv_sa_service_rec>(),
        176usize,
        concat!("Size of: ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_sa_service_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_sa_service_rec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).gid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(gid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).pkey as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).lease as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(lease)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).key as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(key)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data8 as *const _ as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data16 as *const _ as usize },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data32 as *const _ as usize },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data32)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_sa_service_rec>())).data64 as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_sa_service_rec),
            "::",
            stringify!(data64)
        )
    );
}
#[repr(C)]
pub struct ibv_path_record {
    pub service_id: __be64,
    pub dgid: ibv_gid,
    pub sgid: ibv_gid,
    pub dlid: __be16,
    pub slid: __be16,
    pub flowlabel_hoplimit: __be32,
    pub tclass: u8,
    pub reversible_numpath: u8,
    pub pkey: __be16,
    pub qosclass_sl: __be16,
    pub mtu: u8,
    pub rate: u8,
    pub packetlifetime: u8,
    pub preference: u8,
    pub reserved: [u8; 6usize],
}
#[test]
fn bindgen_test_layout_ibv_path_record() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_record>(),
        64usize,
        concat!("Size of: ", stringify!(ibv_path_record))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_record>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_record))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).service_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(service_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dgid as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).sgid as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(sgid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).dlid as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(dlid)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).slid as *const _ as usize },
        42usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(slid)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).flowlabel_hoplimit as *const _ as usize
        },
        44usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(flowlabel_hoplimit)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).tclass as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(tclass)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<ibv_path_record>())).reversible_numpath as *const _ as usize
        },
        49usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reversible_numpath)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).pkey as *const _ as usize },
        50usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(pkey)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).qosclass_sl as *const _ as usize },
        52usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(qosclass_sl)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).mtu as *const _ as usize },
        54usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(mtu)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).rate as *const _ as usize },
        55usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(rate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).packetlifetime as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(packetlifetime)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).preference as *const _ as usize },
        57usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(preference)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_record>())).reserved as *const _ as usize },
        58usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_record),
            "::",
            stringify!(reserved)
        )
    );
}
#[repr(C)]
pub struct ibv_path_data {
    pub flags: u32,
    pub reserved: u32,
    pub path: ibv_path_record,
}
#[test]
fn bindgen_test_layout_ibv_path_data() {
    assert_eq!(
        ::std::mem::size_of::<ibv_path_data>(),
        72usize,
        concat!("Size of: ", stringify!(ibv_path_data))
    );
    assert_eq!(
        ::std::mem::align_of::<ibv_path_data>(),
        8usize,
        concat!("Alignment of ", stringify!(ibv_path_data))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).reserved as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(reserved)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<ibv_path_data>())).path as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(ibv_path_data),
            "::",
            stringify!(path)
        )
    );
}
pub mod rdma_cm_event_type {
    pub type Type = ::std::os::raw::c_uint;
    pub const RDMA_CM_EVENT_ADDR_RESOLVED: Type = 0;
    pub const RDMA_CM_EVENT_ADDR_ERROR: Type = 1;
    pub const RDMA_CM_EVENT_ROUTE_RESOLVED: Type = 2;
    pub const RDMA_CM_EVENT_ROUTE_ERROR: Type = 3;
    pub const RDMA_CM_EVENT_CONNECT_REQUEST: Type = 4;
    pub const RDMA_CM_EVENT_CONNECT_RESPONSE: Type = 5;
    pub const RDMA_CM_EVENT_CONNECT_ERROR: Type = 6;
    pub const RDMA_CM_EVENT_UNREACHABLE: Type = 7;
    pub const RDMA_CM_EVENT_REJECTED: Type = 8;
    pub const RDMA_CM_EVENT_ESTABLISHED: Type = 9;
    pub const RDMA_CM_EVENT_DISCONNECTED: Type = 10;
    pub const RDMA_CM_EVENT_DEVICE_REMOVAL: Type = 11;
    pub const RDMA_CM_EVENT_MULTICAST_JOIN: Type = 12;
    pub const RDMA_CM_EVENT_MULTICAST_ERROR: Type = 13;
    pub const RDMA_CM_EVENT_ADDR_CHANGE: Type = 14;
    pub const RDMA_CM_EVENT_TIMEWAIT_EXIT: Type = 15;
}
pub mod rdma_port_space {
    pub type Type = ::std::os::raw::c_uint;
    pub const RDMA_PS_IPOIB: Type = 2;
    pub const RDMA_PS_TCP: Type = 262;
    pub const RDMA_PS_UDP: Type = 273;
    pub const RDMA_PS_IB: Type = 319;
}
#[repr(C)]
pub struct rdma_addr__bindgen_ty_1 {
    pub src_addr: __BindgenUnionField<libc::sockaddr>,
    pub src_sin: __BindgenUnionField<libc::sockaddr_in>,
    pub src_sin6: __BindgenUnionField<libc::sockaddr_in6>,
    pub src_storage: __BindgenUnionField<libc::sockaddr_storage>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_1>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_1>())).src_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_1),
            "::",
            stringify!(src_storage)
        )
    );
}
#[repr(C)]
pub struct rdma_addr__bindgen_ty_2 {
    pub dst_addr: __BindgenUnionField<libc::sockaddr>,
    pub dst_sin: __BindgenUnionField<libc::sockaddr_in>,
    pub dst_sin6: __BindgenUnionField<libc::sockaddr_in6>,
    pub dst_storage: __BindgenUnionField<libc::sockaddr_storage>,
    pub bindgen_union_field: [u64; 16usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_2() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_2>(),
        128usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_2>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_2))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_addr as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_sin6 as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_sin6)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_addr__bindgen_ty_2>())).dst_storage as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_2),
            "::",
            stringify!(dst_storage)
        )
    );
}
#[repr(C)]
pub struct rdma_addr__bindgen_ty_3 {
    pub ibaddr: __BindgenUnionField<rdma_ib_addr>,
    pub bindgen_union_field: [u64; 5usize],
}
#[test]
fn bindgen_test_layout_rdma_addr__bindgen_ty_3() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addr__bindgen_ty_3>(),
        40usize,
        concat!("Size of: ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addr__bindgen_ty_3>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addr__bindgen_ty_3))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addr__bindgen_ty_3>())).ibaddr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addr__bindgen_ty_3),
            "::",
            stringify!(ibaddr)
        )
    );
}
#[repr(C)]
pub struct rdma_route {
    pub addr: rdma_addr,
    pub path_rec: *mut ibv_sa_path_rec,
    pub num_paths: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_route() {
    assert_eq!(
        ::std::mem::size_of::<rdma_route>(),
        312usize,
        concat!("Size of: ", stringify!(rdma_route))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_route>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_route))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).addr as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).path_rec as *const _ as usize },
        296usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(path_rec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_route>())).num_paths as *const _ as usize },
        304usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_route),
            "::",
            stringify!(num_paths)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_event_channel {
    pub fd: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_rdma_event_channel() {
    assert_eq!(
        ::std::mem::size_of::<rdma_event_channel>(),
        4usize,
        concat!("Size of: ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_event_channel>(),
        4usize,
        concat!("Alignment of ", stringify!(rdma_event_channel))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_event_channel>())).fd as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_event_channel),
            "::",
            stringify!(fd)
        )
    );
}
#[repr(C)]
pub struct rdma_cm_id {
    pub verbs: *mut ibv_context,
    pub channel: *mut rdma_event_channel,
    pub context: *mut ::std::os::raw::c_void,
    pub qp: *mut ibv_qp,
    pub route: rdma_route,
    pub ps: rdma_port_space::Type,
    pub port_num: u8,
    pub event: *mut rdma_cm_event,
    pub send_cq_channel: *mut ibv_comp_channel,
    pub send_cq: *mut ibv_cq,
    pub recv_cq_channel: *mut ibv_comp_channel,
    pub recv_cq: *mut ibv_cq,
    pub srq: *mut ibv_srq,
    pub pd: *mut ibv_pd,
    pub qp_type: ibv_qp_type::Type,
}
#[test]
fn bindgen_test_layout_rdma_cm_id() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_id>(),
        416usize,
        concat!("Size of: ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_id>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_id))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).verbs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(verbs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).channel as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).context as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(context)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).route as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).ps as *const _ as usize },
        344usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(ps)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).port_num as *const _ as usize },
        348usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(port_num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).event as *const _ as usize },
        352usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(event)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq_channel as *const _ as usize },
        360usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).send_cq as *const _ as usize },
        368usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(send_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq_channel as *const _ as usize },
        376usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq_channel)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).recv_cq as *const _ as usize },
        384usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(recv_cq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).srq as *const _ as usize },
        392usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).pd as *const _ as usize },
        400usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(pd)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_id>())).qp_type as *const _ as usize },
        408usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_id),
            "::",
            stringify!(qp_type)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_conn_param {
    pub private_data: *const ::std::os::raw::c_void,
    pub private_data_len: u8,
    pub responder_resources: u8,
    pub initiator_depth: u8,
    pub flow_control: u8,
    pub retry_count: u8,
    pub rnr_retry_count: u8,
    pub srq: u8,
    pub qp_num: u32,
}
#[test]
fn bindgen_test_layout_rdma_conn_param() {
    assert_eq!(
        ::std::mem::size_of::<rdma_conn_param>(),
        24usize,
        concat!("Size of: ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_conn_param>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_conn_param))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).private_data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).private_data_len as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(private_data_len)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_conn_param>())).responder_resources as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(responder_resources)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).initiator_depth as *const _ as usize },
        10usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(initiator_depth)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).flow_control as *const _ as usize },
        11usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(flow_control)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).retry_count as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).rnr_retry_count as *const _ as usize },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(rnr_retry_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).srq as *const _ as usize },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(srq)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_conn_param>())).qp_num as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_conn_param),
            "::",
            stringify!(qp_num)
        )
    );
}
#[repr(C)]
pub struct rdma_cm_event__bindgen_ty_1 {
    pub conn: __BindgenUnionField<rdma_conn_param>,
    pub ud: __BindgenUnionField<rdma_ud_param>,
    pub bindgen_union_field: [u64; 7usize],
}
#[test]
fn bindgen_test_layout_rdma_cm_event__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_event__bindgen_ty_1>(),
        56usize,
        concat!("Size of: ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_event__bindgen_ty_1>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_event__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).conn as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(conn)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_event__bindgen_ty_1>())).ud as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_event__bindgen_ty_1),
            "::",
            stringify!(ud)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_addrinfo {
    pub ai_flags: ::std::os::raw::c_int,
    pub ai_family: ::std::os::raw::c_int,
    pub ai_qp_type: ::std::os::raw::c_int,
    pub ai_port_space: ::std::os::raw::c_int,
    pub ai_src_len: socklen_t,
    pub ai_dst_len: socklen_t,
    pub ai_src_addr: *mut libc::sockaddr,
    pub ai_dst_addr: *mut libc::sockaddr,
    pub ai_src_canonname: *mut ::std::os::raw::c_char,
    pub ai_dst_canonname: *mut ::std::os::raw::c_char,
    pub ai_route_len: usize,
    pub ai_route: *mut ::std::os::raw::c_void,
    pub ai_connect_len: usize,
    pub ai_connect: *mut ::std::os::raw::c_void,
    pub ai_next: *mut rdma_addrinfo,
}
#[test]
fn bindgen_test_layout_rdma_addrinfo() {
    assert_eq!(
        ::std::mem::size_of::<rdma_addrinfo>(),
        96usize,
        concat!("Size of: ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_addrinfo>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_addrinfo))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_flags as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_family as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_family)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_qp_type as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_qp_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_port_space as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_port_space)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_len as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_len as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_addr as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_addr as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_addr)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_src_canonname as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_src_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_dst_canonname as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_dst_canonname)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route_len as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_route as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_route)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect_len as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect_len)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_connect as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_connect)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_addrinfo>())).ai_next as *const _ as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_addrinfo),
            "::",
            stringify!(ai_next)
        )
    );
}
impl rdma_cm_join_mc_attr_mask {
    pub const RDMA_CM_JOIN_MC_ATTR_ADDRESS: rdma_cm_join_mc_attr_mask =
        rdma_cm_join_mc_attr_mask(1);
}
impl rdma_cm_join_mc_attr_mask {
    pub const RDMA_CM_JOIN_MC_ATTR_JOIN_FLAGS: rdma_cm_join_mc_attr_mask =
        rdma_cm_join_mc_attr_mask(2);
}
impl rdma_cm_join_mc_attr_mask {
    pub const RDMA_CM_JOIN_MC_ATTR_RESERVED: rdma_cm_join_mc_attr_mask =
        rdma_cm_join_mc_attr_mask(4);
}
impl ::std::ops::BitOr<rdma_cm_join_mc_attr_mask> for rdma_cm_join_mc_attr_mask {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rdma_cm_join_mc_attr_mask(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for rdma_cm_join_mc_attr_mask {
    #[inline]
    fn bitor_assign(&mut self, rhs: rdma_cm_join_mc_attr_mask) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<rdma_cm_join_mc_attr_mask> for rdma_cm_join_mc_attr_mask {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rdma_cm_join_mc_attr_mask(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for rdma_cm_join_mc_attr_mask {
    #[inline]
    fn bitand_assign(&mut self, rhs: rdma_cm_join_mc_attr_mask) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rdma_cm_join_mc_attr_mask(pub ::std::os::raw::c_uint);
impl rdma_cm_mc_join_flags {
    pub const RDMA_MC_JOIN_FLAG_FULLMEMBER: rdma_cm_mc_join_flags = rdma_cm_mc_join_flags(0);
}
impl rdma_cm_mc_join_flags {
    pub const RDMA_MC_JOIN_FLAG_SENDONLY_FULLMEMBER: rdma_cm_mc_join_flags =
        rdma_cm_mc_join_flags(1);
}
impl rdma_cm_mc_join_flags {
    pub const RDMA_MC_JOIN_FLAG_RESERVED: rdma_cm_mc_join_flags = rdma_cm_mc_join_flags(2);
}
impl ::std::ops::BitOr<rdma_cm_mc_join_flags> for rdma_cm_mc_join_flags {
    type Output = Self;
    #[inline]
    fn bitor(self, other: Self) -> Self {
        rdma_cm_mc_join_flags(self.0 | other.0)
    }
}
impl ::std::ops::BitOrAssign for rdma_cm_mc_join_flags {
    #[inline]
    fn bitor_assign(&mut self, rhs: rdma_cm_mc_join_flags) {
        self.0 |= rhs.0;
    }
}
impl ::std::ops::BitAnd<rdma_cm_mc_join_flags> for rdma_cm_mc_join_flags {
    type Output = Self;
    #[inline]
    fn bitand(self, other: Self) -> Self {
        rdma_cm_mc_join_flags(self.0 & other.0)
    }
}
impl ::std::ops::BitAndAssign for rdma_cm_mc_join_flags {
    #[inline]
    fn bitand_assign(&mut self, rhs: rdma_cm_mc_join_flags) {
        self.0 &= rhs.0;
    }
}
#[repr(transparent)]
#[derive(Copy, Clone, Hash, PartialEq, Eq)]
pub struct rdma_cm_mc_join_flags(pub ::std::os::raw::c_uint);
#[repr(C)]
#[derive(Copy, Clone)]
pub struct rdma_cm_join_mc_attr_ex {
    pub comp_mask: u32,
    pub join_flags: u32,
    pub addr: *mut libc::sockaddr,
}
#[test]
fn bindgen_test_layout_rdma_cm_join_mc_attr_ex() {
    assert_eq!(
        ::std::mem::size_of::<rdma_cm_join_mc_attr_ex>(),
        16usize,
        concat!("Size of: ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        ::std::mem::align_of::<rdma_cm_join_mc_attr_ex>(),
        8usize,
        concat!("Alignment of ", stringify!(rdma_cm_join_mc_attr_ex))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).comp_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(comp_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).join_flags as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(join_flags)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<rdma_cm_join_mc_attr_ex>())).addr as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(rdma_cm_join_mc_attr_ex),
            "::",
            stringify!(addr)
        )
    );
}
extern "C" {
    pub fn rdma_create_event_channel() -> *mut rdma_event_channel;
}
extern "C" {
    pub fn rdma_destroy_event_channel(channel: *mut rdma_event_channel);
}
extern "C" {
    pub fn rdma_create_id(
        channel: *mut rdma_event_channel,
        id: *mut *mut rdma_cm_id,
        context: *mut ::std::os::raw::c_void,
        ps: rdma_port_space::Type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_ep(
        id: *mut *mut rdma_cm_id,
        res: *mut rdma_addrinfo,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_destroy_ep(id: *mut rdma_cm_id);
}
extern "C" {
    pub fn rdma_destroy_id(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_bind_addr(id: *mut rdma_cm_id, addr: *mut libc::sockaddr) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_resolve_addr(
        id: *mut rdma_cm_id,
        src_addr: *mut libc::sockaddr,
        dst_addr: *mut libc::sockaddr,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_resolve_route(
        id: *mut rdma_cm_id,
        timeout_ms: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_qp(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        qp_init_attr: *mut ibv_qp_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_qp_ex(
        id: *mut rdma_cm_id,
        qp_init_attr: *mut ibv_qp_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_destroy_qp(id: *mut rdma_cm_id);
}
extern "C" {
    pub fn rdma_connect(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_establish(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_listen(
        id: *mut rdma_cm_id,
        backlog: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_request(
        listen: *mut rdma_cm_id,
        id: *mut *mut rdma_cm_id,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_accept(
        id: *mut rdma_cm_id,
        conn_param: *mut rdma_conn_param,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_reject(
        id: *mut rdma_cm_id,
        private_data: *const ::std::os::raw::c_void,
        private_data_len: u8,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_notify(id: *mut rdma_cm_id, event: ibv_event_type::Type) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_disconnect(id: *mut rdma_cm_id) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_join_multicast(
        id: *mut rdma_cm_id,
        addr: *mut libc::sockaddr,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_leave_multicast(
        id: *mut rdma_cm_id,
        addr: *mut libc::sockaddr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_join_multicast_ex(
        id: *mut rdma_cm_id,
        mc_join_attr: *mut rdma_cm_join_mc_attr_ex,
        context: *mut ::std::os::raw::c_void,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_cm_event(
        channel: *mut rdma_event_channel,
        event: *mut *mut rdma_cm_event,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_ack_cm_event(event: *mut rdma_cm_event) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_get_src_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    pub fn rdma_get_dst_port(id: *mut rdma_cm_id) -> __be16;
}
extern "C" {
    pub fn rdma_get_devices(num_devices: *mut ::std::os::raw::c_int) -> *mut *mut ibv_context;
}
extern "C" {
    pub fn rdma_free_devices(list: *mut *mut ibv_context);
}
extern "C" {
    pub fn rdma_event_str(event: rdma_cm_event_type::Type) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn rdma_set_option(
        id: *mut rdma_cm_id,
        level: ::std::os::raw::c_int,
        optname: ::std::os::raw::c_int,
        optval: *mut ::std::os::raw::c_void,
        optlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_migrate_id(
        id: *mut rdma_cm_id,
        channel: *mut rdma_event_channel,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_getaddrinfo(
        node: *const ::std::os::raw::c_char,
        service: *const ::std::os::raw::c_char,
        hints: *const rdma_addrinfo,
        res: *mut *mut rdma_addrinfo,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_freeaddrinfo(res: *mut rdma_addrinfo);
}
extern "C" {
    pub fn rdma_init_qp_attr(
        id: *mut rdma_cm_id,
        qp_attr: *mut ibv_qp_attr,
        qp_attr_mask: *mut ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_srq(
        id: *mut rdma_cm_id,
        pd: *mut ibv_pd,
        attr: *mut ibv_srq_init_attr,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_create_srq_ex(
        id: *mut rdma_cm_id,
        attr: *mut ibv_srq_init_attr_ex,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn rdma_destroy_srq(id: *mut rdma_cm_id);
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct verbs_ex_private {
    pub _address: u8,
}
